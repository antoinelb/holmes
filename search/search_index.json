{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"HOLMES","text":"<p>HydrOLogical Modeling Educational Software</p> <p>HOLMES is a web-based hydrological modeling tool designed for teaching operational hydrology. Developed at Universit\u00e9 Laval, Qu\u00e9bec, Canada.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Multiple Hydrological Models: GR4J (4 parameters) and Bucket (6 parameters) rainfall-runoff models</li> <li>Snow Modeling: CemaNeige degree-day model with multi-elevation band support</li> <li>Automatic Calibration: SCE-UA (Shuffled Complex Evolution) optimization algorithm</li> <li>Climate Projections: Run future scenarios with calibrated model parameters</li> <li>Interactive Interface: Real-time parameter adjustment and streamflow visualization</li> <li>High Performance: Rust-powered computational engine with Python integration</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Install HOLMES:</p> <pre><code>pip install holmes-hydro\n</code></pre> <p>Start the server:</p> <pre><code>holmes\n</code></pre> <p>Open your browser at http://127.0.0.1:8000.</p> <p> Get Started  User Guide</p>"},{"location":"#documentation-sections","title":"Documentation Sections","text":"<ul> <li> <p> Getting Started</p> <p>Install HOLMES and run your first simulation in minutes.</p> <p> Installation</p> </li> <li> <p> User Guide</p> <p>Learn how to use the web interface for calibration, simulation, and projection.</p> <p> User Guide</p> </li> <li> <p> Concepts</p> <p>Understand the hydrological models, calibration algorithms, and metrics.</p> <p> Concepts</p> </li> <li> <p> Developer Guide</p> <p>Architecture overview and API documentation.</p> <p> Developer Guide</p> </li> </ul>"},{"location":"#architecture-overview","title":"Architecture Overview","text":"<p>HOLMES uses a three-tier architecture:</p> Layer Technology Purpose Frontend Vanilla JavaScript, D3.js Interactive web interface Backend Python, Starlette, Uvicorn API routing, data loading, orchestration Compute Rust (holmes-rs), PyO3 High-performance numerical models <p>Communication between frontend and backend uses WebSockets for real-time updates during calibration.</p>"},{"location":"#license","title":"License","text":"<p>HOLMES is released under the MIT License.</p>"},{"location":"#links","title":"Links","text":"<ul> <li> GitHub Repository</li> <li> PyPI Package</li> </ul>"},{"location":"api-reference/","title":"API Reference","text":"<p>Auto-generated documentation from the HOLMES Python source code.</p>"},{"location":"api-reference/#top-level-modules","title":"Top-level Modules","text":"<ul> <li>data - Data loading utilities</li> <li>app - Application entry point</li> <li>config - Configuration management</li> <li>exceptions - Custom exceptions</li> <li>logging - Logging setup</li> <li>validation - Input validation</li> </ul>"},{"location":"api-reference/#packages","title":"Packages","text":"<ul> <li>api - HTTP and WebSocket route handlers</li> <li>models - Model orchestration layer</li> <li>utils - Utility functions</li> </ul>"},{"location":"api-reference/app/","title":"app","text":""},{"location":"api-reference/config/","title":"config","text":"<p>Configuration module for HOLMES.</p> <p>Loads configuration from environment variables and .env file, with validation to ensure values are within acceptable ranges.</p>"},{"location":"api-reference/data/","title":"data","text":"<p>Data loading utilities for HOLMES.</p> <p>This module provides functions for loading catchment observation data, CemaNeige snow model configuration, and climate projection data.</p>"},{"location":"api-reference/data/#holmes.data.read_data","title":"read_data","text":"<pre><code>read_data(\n    catchment: str, start: str, end: str, *, warmup_length: int = 3\n) -&gt; tuple[DataFrame, int]\n</code></pre> <p>Read observation data for a catchment within a date range.</p> <p>Parameters:</p> Name Type Description Default <code>catchment</code> <code>str</code> <p>Catchment name</p> required <code>start</code> <code>str</code> <p>Start date in \"%Y-%m-%d\" format</p> required <code>end</code> <code>str</code> <p>End date in \"%Y-%m-%d\" format</p> required <code>warmup_length</code> <code>int</code> <p>Number of years for warmup period (default 3)</p> <code>3</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with columns: date, precipitation, pet, streamflow, temperature</p> <code>int</code> <p>Number of warmup steps at the start of the dataframe (to exclude from objectives)</p> <p>Raises:</p> Type Description <code>HolmesDataError</code> <p>If catchment doesn't exist, dates are invalid, or no data in range</p> Source code in <code>src/holmes/data.py</code> <pre><code>def read_data(\n    catchment: str,\n    start: str,\n    end: str,\n    *,\n    warmup_length: int = 3,\n) -&gt; tuple[pl.DataFrame, int]:\n    \"\"\"\n    Read observation data for a catchment within a date range.\n\n    Parameters\n    ----------\n    catchment : str\n        Catchment name\n    start : str\n        Start date in \"%Y-%m-%d\" format\n    end : str\n        End date in \"%Y-%m-%d\" format\n    warmup_length : int\n        Number of years for warmup period (default 3)\n\n    Returns\n    -------\n    pl.DataFrame\n        DataFrame with columns: date, precipitation, pet, streamflow, temperature\n    int\n        Number of warmup steps at the start of the dataframe (to exclude from objectives)\n\n    Raises\n    ------\n    HolmesDataError\n        If catchment doesn't exist, dates are invalid, or no data in range\n    \"\"\"\n    try:\n        validate_catchment_exists(catchment)\n    except ValueError as exc:\n        raise HolmesDataError(str(exc)) from exc\n\n    try:\n        start_dt, end_dt = validate_date_range(start, end)\n    except ValueError as exc:\n        raise HolmesDataError(str(exc)) from exc\n\n    warmup_days = 365 * warmup_length\n    warmup_start = start_dt - timedelta(days=warmup_days)\n\n    data_ = read_catchment_data(catchment).rename(\n        {\n            \"Date\": \"date\",\n            \"P\": \"precipitation\",\n            \"E0\": \"pet\",\n            \"Qo\": \"streamflow\",\n            \"T\": \"temperature\",\n        },\n        strict=False,\n    )\n\n    data_ = data_.filter(pl.col(\"date\").is_between(warmup_start, end_dt))\n    data_ = data_.collect()\n\n    warmup_steps = data_.filter(pl.col(\"date\") &lt; start_dt).shape[0]\n\n    if len(data_) == 0:\n        raise HolmesDataError(\n            f\"No data found for catchment '{catchment}' in period {start} to {end}. \"\n            f\"Check that the date range falls within the available data period.\"\n        )\n\n    return data_, warmup_steps\n</code></pre>"},{"location":"api-reference/data/#holmes.data.get_available_catchments","title":"get_available_catchments  <code>cached</code>","text":"<pre><code>get_available_catchments() -&gt; tuple[tuple[str, bool, tuple[str, str]], ...]\n</code></pre> <p>Determines which catchments are available in the data and if snow info is available for each.</p> <p>Returns a tuple (for hashability with lru_cache) where each element is: (, , (, )) <p>Returns:</p> Type Description <code>tuple[tuple[str, bool, tuple[str, str]], ...]</code> <p>Available catchments with their metadata</p> Source code in <code>src/holmes/data.py</code> <pre><code>@lru_cache(maxsize=1)\ndef get_available_catchments() -&gt; (\n    tuple[tuple[str, bool, tuple[str, str]], ...]\n):\n    \"\"\"\n    Determines which catchments are available in the data and if snow info is\n    available for each.\n\n    Returns a tuple (for hashability with lru_cache) where each element is:\n    (&lt;catchment name&gt;, &lt;snow info is available&gt;, (&lt;period min&gt;, &lt;period max&gt;))\n\n    Returns\n    -------\n    tuple[tuple[str, bool, tuple[str, str]], ...]\n        Available catchments with their metadata\n    \"\"\"\n    catchments = [\n        file.stem.replace(\"_Observations\", \"\")\n        for file in data_dir.glob(\"*_Observations.csv\")\n    ]\n    return tuple(\n        sorted(\n            [\n                (\n                    catchment,\n                    (data_dir / f\"{catchment}_CemaNeigeInfo.csv\").exists(),\n                    _get_available_period(catchment),\n                )\n                for catchment in catchments\n            ],\n            key=lambda c: c[0],\n        )\n    )\n</code></pre>"},{"location":"api-reference/data/#holmes.data.read_catchment_data","title":"read_catchment_data","text":"<pre><code>read_catchment_data(catchment: str) -&gt; LazyFrame\n</code></pre> <p>Read raw catchment observation data as a lazy frame.</p> <p>Parameters:</p> Name Type Description Default <code>catchment</code> <code>str</code> <p>Catchment name</p> required <p>Returns:</p> Type Description <code>LazyFrame</code> <p>Lazy frame with observation data</p> <p>Raises:</p> Type Description <code>HolmesDataError</code> <p>If CSV file is malformed or missing required columns</p> Source code in <code>src/holmes/data.py</code> <pre><code>def read_catchment_data(catchment: str) -&gt; pl.LazyFrame:\n    \"\"\"\n    Read raw catchment observation data as a lazy frame.\n\n    Parameters\n    ----------\n    catchment : str\n        Catchment name\n\n    Returns\n    -------\n    pl.LazyFrame\n        Lazy frame with observation data\n\n    Raises\n    ------\n    HolmesDataError\n        If CSV file is malformed or missing required columns\n    \"\"\"\n    path = data_dir / f\"{catchment}_Observations.csv\"\n\n    # Eagerly check file existence since scan_csv is lazy\n    if not path.exists():\n        raise HolmesDataError(f\"Data file not found: {path}\")\n\n    try:\n        df = pl.scan_csv(path)\n    except pl.exceptions.ComputeError as exc:\n        raise HolmesDataError(\n            f\"Failed to parse CSV file '{path}': {exc}\"\n        ) from exc\n    except PermissionError as exc:\n        raise HolmesDataError(f\"Permission denied reading '{path}'\") from exc\n\n    # P4-DATA-02: Validate required columns exist\n    try:\n        schema = df.collect_schema()\n        actual_columns = set(schema.names())\n    except pl.exceptions.ComputeError as exc:\n        raise HolmesDataError(\n            f\"Failed to read schema from '{path}': {exc}\"\n        ) from exc\n\n    missing_required = OBSERVATION_REQUIRED_COLUMNS - actual_columns\n    if missing_required:\n        raise HolmesDataError(\n            f\"CSV file '{path}' is missing required columns: {missing_required}. \"\n            f\"Found columns: {actual_columns}\"\n        )\n\n    # Warn about missing optional columns (e.g., temperature for snow modeling)\n    missing_optional = OBSERVATION_OPTIONAL_COLUMNS - actual_columns\n    if missing_optional:\n        logger.debug(\n            f\"CSV file '{path}' is missing optional columns: {missing_optional}. \"\n            f\"Snow modeling may not be available for this catchment.\"\n        )\n\n    return df.with_columns(pl.col(\"Date\").str.strptime(pl.Date, \"%Y-%m-%d\"))\n</code></pre>"},{"location":"api-reference/data/#holmes.data.read_cemaneige_info","title":"read_cemaneige_info","text":"<pre><code>read_cemaneige_info(catchment: str) -&gt; dict[str, Any]\n</code></pre> <p>Read CemaNeige configuration parameters for a catchment.</p> <p>Parameters:</p> Name Type Description Default <code>catchment</code> <code>str</code> <p>Catchment name</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with keys: qnbv, altitude_layers, median_altitude, latitude, n_altitude_layers</p> <p>Raises:</p> Type Description <code>HolmesDataError</code> <p>If file is missing, malformed, or missing required keys</p> Source code in <code>src/holmes/data.py</code> <pre><code>def read_cemaneige_info(catchment: str) -&gt; dict[str, Any]:\n    \"\"\"\n    Read CemaNeige configuration parameters for a catchment.\n\n    Parameters\n    ----------\n    catchment : str\n        Catchment name\n\n    Returns\n    -------\n    dict\n        Dictionary with keys: qnbv, altitude_layers, median_altitude, latitude,\n        n_altitude_layers\n\n    Raises\n    ------\n    HolmesDataError\n        If file is missing, malformed, or missing required keys\n    \"\"\"\n    path = data_dir / f\"{catchment}_CemaNeigeInfo.csv\"\n\n    # P4-DATA-06: Handle file errors explicitly\n    try:\n        with open(path, \"r\") as csv_file:\n            reader = csv.reader(csv_file)\n            info = dict(reader)\n    except FileNotFoundError as exc:\n        raise HolmesDataError(\n            f\"CemaNeige info file not found for catchment '{catchment}': {path}\"\n        ) from exc\n    except PermissionError as exc:\n        raise HolmesDataError(\n            f\"Permission denied reading CemaNeige file: {path}\"\n        ) from exc\n    except csv.Error as exc:\n        raise HolmesDataError(\n            f\"Failed to parse CemaNeige CSV file '{path}': {exc}\"\n        ) from exc\n\n    # P4-DATA-07: Validate required keys exist\n    missing_keys = CEMANEIGE_REQUIRED_KEYS - set(info.keys())\n    if missing_keys:\n        raise HolmesDataError(\n            f\"CemaNeige file '{path}' is missing required keys: {missing_keys}. \"\n            f\"Found keys: {set(info.keys())}\"\n        )\n\n    # P4-DATA-07: Safe parsing of altitude layers\n    try:\n        altitude_str = info[\"AltiBand\"]\n        if not altitude_str or altitude_str.strip() == \"\":\n            raise HolmesDataError(\n                f\"Empty AltiBand value in CemaNeige file '{path}'\"\n            )\n        altitude_layers = np.array(\n            [float(x.strip()) for x in altitude_str.split(\";\") if x.strip()]\n        )\n        if len(altitude_layers) == 0:\n            raise HolmesDataError(\n                f\"No altitude layers found in AltiBand: '{altitude_str}'\"\n            )\n    except ValueError as exc:\n        raise HolmesDataError(\n            f\"Invalid altitude layer value in '{path}': {exc}\"\n        ) from exc\n\n    # Safe parsing of numeric values\n    try:\n        qnbv = float(info[\"QNBV\"])\n        median_altitude = float(info[\"Z50\"])\n        latitude = float(info[\"Lat\"])\n    except ValueError as exc:\n        raise HolmesDataError(\n            f\"Invalid numeric value in CemaNeige file '{path}': {exc}\"\n        ) from exc\n\n    return {\n        \"qnbv\": qnbv,\n        \"altitude_layers\": altitude_layers,\n        \"median_altitude\": median_altitude,\n        \"latitude\": latitude,\n        \"n_altitude_layers\": len(altitude_layers),\n    }\n</code></pre>"},{"location":"api-reference/data/#holmes.data.read_projection_data","title":"read_projection_data","text":"<pre><code>read_projection_data(catchment: str) -&gt; LazyFrame\n</code></pre> <p>Read climate projection data for a catchment.</p> <p>Parameters:</p> Name Type Description Default <code>catchment</code> <code>str</code> <p>Catchment name</p> required <p>Returns:</p> Type Description <code>LazyFrame</code> <p>Lazy frame with projection data</p> <p>Raises:</p> Type Description <code>HolmesDataError</code> <p>If file not found or malformed</p> Source code in <code>src/holmes/data.py</code> <pre><code>def read_projection_data(catchment: str) -&gt; pl.LazyFrame:\n    \"\"\"\n    Read climate projection data for a catchment.\n\n    Parameters\n    ----------\n    catchment : str\n        Catchment name\n\n    Returns\n    -------\n    pl.LazyFrame\n        Lazy frame with projection data\n\n    Raises\n    ------\n    HolmesDataError\n        If file not found or malformed\n    \"\"\"\n    path = data_dir / f\"{catchment}_Projections.csv\"\n\n    # Eagerly check file existence since scan_csv is lazy\n    if not path.exists():\n        raise HolmesDataError(f\"Projection data file not found: {path}\")\n\n    try:\n        return pl.scan_csv(path).with_columns(\n            pl.col(\"date\").str.strptime(pl.Date, \"%Y-%m-%d\")\n        )\n    except PermissionError as exc:\n        raise HolmesDataError(\n            f\"Permission denied reading projection file: {path}\"\n        ) from exc\n    except pl.exceptions.ComputeError as exc:\n        raise HolmesDataError(\n            f\"Failed to parse projection CSV file '{path}': {exc}\"\n        ) from exc\n</code></pre>"},{"location":"api-reference/exceptions/","title":"exceptions","text":"<p>Custom exceptions for HOLMES.</p> <p>This module provides a unified exception hierarchy for the HOLMES application, re-exporting Rust exceptions and adding Python-specific exceptions.</p>"},{"location":"api-reference/exceptions/#holmes.exceptions.HolmesDataError","title":"HolmesDataError","text":"<p>               Bases: <code>Exception</code></p> <p>Raised for data loading and parsing errors.</p> <p>This exception is used when: - CSV files are malformed or have missing columns - Required data files are not found - Date ranges are invalid or yield empty results - CemaNeige configuration parsing fails</p> Source code in <code>src/holmes/exceptions.py</code> <pre><code>class HolmesDataError(Exception):\n    \"\"\"\n    Raised for data loading and parsing errors.\n\n    This exception is used when:\n    - CSV files are malformed or have missing columns\n    - Required data files are not found\n    - Date ranges are invalid or yield empty results\n    - CemaNeige configuration parsing fails\n    \"\"\"\n</code></pre>"},{"location":"api-reference/exceptions/#holmes.exceptions.HolmesWebSocketError","title":"HolmesWebSocketError","text":"<p>               Bases: <code>Exception</code></p> <p>Raised for WebSocket communication errors.</p> <p>This exception is used when: - WebSocket send operations fail - Connection state is invalid - Message parsing fails</p> Source code in <code>src/holmes/exceptions.py</code> <pre><code>class HolmesWebSocketError(Exception):\n    \"\"\"\n    Raised for WebSocket communication errors.\n\n    This exception is used when:\n    - WebSocket send operations fail\n    - Connection state is invalid\n    - Message parsing fails\n    \"\"\"\n</code></pre>"},{"location":"api-reference/exceptions/#holmes.exceptions.HolmesConfigError","title":"HolmesConfigError","text":"<p>               Bases: <code>Exception</code></p> <p>Raised for configuration validation errors.</p> <p>This exception is used when: - Environment variables have invalid values - Port numbers are out of range - Host addresses are invalid</p> Source code in <code>src/holmes/exceptions.py</code> <pre><code>class HolmesConfigError(Exception):\n    \"\"\"\n    Raised for configuration validation errors.\n\n    This exception is used when:\n    - Environment variables have invalid values\n    - Port numbers are out of range\n    - Host addresses are invalid\n    \"\"\"\n</code></pre>"},{"location":"api-reference/logging/","title":"logging","text":""},{"location":"api-reference/logging/#holmes.logging.ColourFormatter","title":"ColourFormatter","text":"<p>               Bases: <code>Formatter</code></p> <p>Custom logging formatter that adds color to log level names.</p> <p>This formatter applies color coding to log level names in the console output to improve readability and visual distinction between different log levels.</p> Source code in <code>src/holmes/logging.py</code> <pre><code>class ColourFormatter(logging.Formatter):  # pragma: no cover\n    \"\"\"\n    Custom logging formatter that adds color to log level names.\n\n    This formatter applies color coding to log level names in the console\n    output to improve readability and visual distinction between different\n    log levels.\n    \"\"\"\n\n    level_name_colours = {\n        logging.DEBUG: lambda level: click.style(str(level), fg=\"cyan\"),\n        logging.INFO: lambda level: click.style(str(level), fg=\"green\"),\n        logging.WARNING: lambda level: click.style(str(level), fg=\"yellow\"),\n        logging.ERROR: lambda level: click.style(str(level), fg=\"red\"),\n        logging.CRITICAL: lambda level: click.style(\n            str(level), fg=\"bright_red\"\n        ),\n    }\n\n    def __init__(\n        self: \"ColourFormatter\",\n        fmt: Optional[str] = None,\n        datefmt: Optional[str] = None,\n        style: Literal[\"%\", \"{\", \"$\"] = \"%\",\n        use_colours: Optional[bool] = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the ColourFormatter.\n\n        Parameters\n        ----------\n        fmt : Optional[str], default=None\n            Format string for log messages\n        datefmt : Optional[str], default=None\n            Format string for dates\n        style : Literal[\"%\", \"{\", \"$\"], default=\"%\"\n            Style of the format string\n        use_colours : Optional[bool], default=None\n            Whether to use colors. If None, colors are used if stdout is a TTY\n        \"\"\"\n        if use_colours in (True, False):\n            self.use_colours = use_colours  # pragma: no cover\n        else:\n            self.use_colours = sys.stdout.isatty()\n        super().__init__(fmt=fmt, datefmt=datefmt, style=style)\n\n    def colour_level_name(\n        self: \"ColourFormatter\", level_name: str, level_no: int\n    ) -&gt; str:\n        \"\"\"\n        Apply color to a log level name based on its severity.\n\n        Parameters\n        ----------\n        level_name : str\n            Name of the log level to color\n        level_no : int\n            Numeric value of the log level\n\n        Returns\n        -------\n        str\n            Colored log level name\n        \"\"\"\n        fct = self.level_name_colours.get(\n            level_no,\n            lambda level_name: str(  # pylint: disable=unnecessary-lambda\n                level_name\n            ),\n        )  # pragma: no cover\n        return fct(level_name)  # pragma: no cover\n\n    def formatMessage(\n        self: \"ColourFormatter\", record: logging.LogRecord\n    ) -&gt; str:\n        \"\"\"\n        Format a log record with colored level name if colors are enabled.\n\n        Parameters\n        ----------\n        record : logging.LogRecord\n            Log record to format\n\n        Returns\n        -------\n        str\n            Formatted log message\n        \"\"\"\n        if self.use_colours:\n            record.levelname = self.colour_level_name(\n                record.levelname, record.levelno\n            )  # pragma: no cover\n        return super().formatMessage(record)\n</code></pre>"},{"location":"api-reference/logging/#holmes.logging.ColourFormatter.__init__","title":"__init__","text":"<pre><code>__init__(\n    fmt: Optional[str] = None,\n    datefmt: Optional[str] = None,\n    style: Literal[\"%\", \"{\", \"$\"] = \"%\",\n    use_colours: Optional[bool] = None,\n) -&gt; None\n</code></pre> <p>Initialize the ColourFormatter.</p> <p>Parameters:</p> Name Type Description Default <code>fmt</code> <code>Optional[str]</code> <p>Format string for log messages</p> <code>None</code> <code>datefmt</code> <code>Optional[str]</code> <p>Format string for dates</p> <code>None</code> <code>style</code> <code>Literal['%', '{', '$']</code> <p>Style of the format string</p> <code>\"%\"</code> <code>use_colours</code> <code>Optional[bool]</code> <p>Whether to use colors. If None, colors are used if stdout is a TTY</p> <code>None</code> Source code in <code>src/holmes/logging.py</code> <pre><code>def __init__(\n    self: \"ColourFormatter\",\n    fmt: Optional[str] = None,\n    datefmt: Optional[str] = None,\n    style: Literal[\"%\", \"{\", \"$\"] = \"%\",\n    use_colours: Optional[bool] = None,\n) -&gt; None:\n    \"\"\"\n    Initialize the ColourFormatter.\n\n    Parameters\n    ----------\n    fmt : Optional[str], default=None\n        Format string for log messages\n    datefmt : Optional[str], default=None\n        Format string for dates\n    style : Literal[\"%\", \"{\", \"$\"], default=\"%\"\n        Style of the format string\n    use_colours : Optional[bool], default=None\n        Whether to use colors. If None, colors are used if stdout is a TTY\n    \"\"\"\n    if use_colours in (True, False):\n        self.use_colours = use_colours  # pragma: no cover\n    else:\n        self.use_colours = sys.stdout.isatty()\n    super().__init__(fmt=fmt, datefmt=datefmt, style=style)\n</code></pre>"},{"location":"api-reference/logging/#holmes.logging.ColourFormatter.colour_level_name","title":"colour_level_name","text":"<pre><code>colour_level_name(level_name: str, level_no: int) -&gt; str\n</code></pre> <p>Apply color to a log level name based on its severity.</p> <p>Parameters:</p> Name Type Description Default <code>level_name</code> <code>str</code> <p>Name of the log level to color</p> required <code>level_no</code> <code>int</code> <p>Numeric value of the log level</p> required <p>Returns:</p> Type Description <code>str</code> <p>Colored log level name</p> Source code in <code>src/holmes/logging.py</code> <pre><code>def colour_level_name(\n    self: \"ColourFormatter\", level_name: str, level_no: int\n) -&gt; str:\n    \"\"\"\n    Apply color to a log level name based on its severity.\n\n    Parameters\n    ----------\n    level_name : str\n        Name of the log level to color\n    level_no : int\n        Numeric value of the log level\n\n    Returns\n    -------\n    str\n        Colored log level name\n    \"\"\"\n    fct = self.level_name_colours.get(\n        level_no,\n        lambda level_name: str(  # pylint: disable=unnecessary-lambda\n            level_name\n        ),\n    )  # pragma: no cover\n    return fct(level_name)  # pragma: no cover\n</code></pre>"},{"location":"api-reference/logging/#holmes.logging.ColourFormatter.formatMessage","title":"formatMessage","text":"<pre><code>formatMessage(record: LogRecord) -&gt; str\n</code></pre> <p>Format a log record with colored level name if colors are enabled.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>LogRecord</code> <p>Log record to format</p> required <p>Returns:</p> Type Description <code>str</code> <p>Formatted log message</p> Source code in <code>src/holmes/logging.py</code> <pre><code>def formatMessage(\n    self: \"ColourFormatter\", record: logging.LogRecord\n) -&gt; str:\n    \"\"\"\n    Format a log record with colored level name if colors are enabled.\n\n    Parameters\n    ----------\n    record : logging.LogRecord\n        Log record to format\n\n    Returns\n    -------\n    str\n        Formatted log message\n    \"\"\"\n    if self.use_colours:\n        record.levelname = self.colour_level_name(\n            record.levelname, record.levelno\n        )  # pragma: no cover\n    return super().formatMessage(record)\n</code></pre>"},{"location":"api-reference/logging/#holmes.logging.RouteFilter","title":"RouteFilter","text":"<p>               Bases: <code>Filter</code></p> <p>Filter for removing common route access logs.</p> <p>This filter prevents logging of successful (200) GET requests to common routes like the homepage, static files, and ping endpoint to reduce log noise.</p> Source code in <code>src/holmes/logging.py</code> <pre><code>class RouteFilter(logging.Filter):\n    \"\"\"\n    Filter for removing common route access logs.\n\n    This filter prevents logging of successful (200) GET requests to common routes\n    like the homepage, static files, and ping endpoint to reduce log noise.\n    \"\"\"\n\n    def __init__(self: \"RouteFilter\", *args: str, **kwargs: str) -&gt; None:\n        \"\"\"\n        Initialize the RouteFilter.\n\n        Parameters\n        ----------\n        *args : str\n            Positional arguments passed to the parent class\n        **kwargs : str\n            Keyword arguments passed to the parent class\n        \"\"\"\n        super().__init__(*args, **kwargs)\n\n    def filter(self: \"RouteFilter\", record: logging.LogRecord) -&gt; bool:\n        \"\"\"\n        Filter log records based on common routes.\n\n        This method filters out successful (200) GET requests to common routes\n        to reduce log verbosity.\n\n        Parameters\n        ----------\n        record : logging.LogRecord\n            Log record to filter\n\n        Returns\n        -------\n        bool\n            True if the record should be logged, False if it should be filtered out\n        \"\"\"\n        routes = [\n            \"/ping\",\n            \"/health\",\n            \"/\",\n            \"/static/scripts/.+.js\",\n            \"/static/styles/.+.css\",\n        ]\n        msg = record.getMessage()\n        return all(\n            re.search(f'\"GET {route}(?:\\\\?\\\\S+)? HTTP/1.1\" 200', msg) is None\n            for route in routes\n        )\n</code></pre>"},{"location":"api-reference/logging/#holmes.logging.RouteFilter.__init__","title":"__init__","text":"<pre><code>__init__(*args: str, **kwargs: str) -&gt; None\n</code></pre> <p>Initialize the RouteFilter.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>str</code> <p>Positional arguments passed to the parent class</p> <code>()</code> <code>**kwargs</code> <code>str</code> <p>Keyword arguments passed to the parent class</p> <code>{}</code> Source code in <code>src/holmes/logging.py</code> <pre><code>def __init__(self: \"RouteFilter\", *args: str, **kwargs: str) -&gt; None:\n    \"\"\"\n    Initialize the RouteFilter.\n\n    Parameters\n    ----------\n    *args : str\n        Positional arguments passed to the parent class\n    **kwargs : str\n        Keyword arguments passed to the parent class\n    \"\"\"\n    super().__init__(*args, **kwargs)\n</code></pre>"},{"location":"api-reference/logging/#holmes.logging.RouteFilter.filter","title":"filter","text":"<pre><code>filter(record: LogRecord) -&gt; bool\n</code></pre> <p>Filter log records based on common routes.</p> <p>This method filters out successful (200) GET requests to common routes to reduce log verbosity.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>LogRecord</code> <p>Log record to filter</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the record should be logged, False if it should be filtered out</p> Source code in <code>src/holmes/logging.py</code> <pre><code>def filter(self: \"RouteFilter\", record: logging.LogRecord) -&gt; bool:\n    \"\"\"\n    Filter log records based on common routes.\n\n    This method filters out successful (200) GET requests to common routes\n    to reduce log verbosity.\n\n    Parameters\n    ----------\n    record : logging.LogRecord\n        Log record to filter\n\n    Returns\n    -------\n    bool\n        True if the record should be logged, False if it should be filtered out\n    \"\"\"\n    routes = [\n        \"/ping\",\n        \"/health\",\n        \"/\",\n        \"/static/scripts/.+.js\",\n        \"/static/styles/.+.css\",\n    ]\n    msg = record.getMessage()\n    return all(\n        re.search(f'\"GET {route}(?:\\\\?\\\\S+)? HTTP/1.1\" 200', msg) is None\n        for route in routes\n    )\n</code></pre>"},{"location":"api-reference/logging/#holmes.logging.get_correlation_id","title":"get_correlation_id","text":"<pre><code>get_correlation_id() -&gt; str | None\n</code></pre> <p>Get the current correlation ID for request tracing.</p> Source code in <code>src/holmes/logging.py</code> <pre><code>def get_correlation_id() -&gt; str | None:\n    \"\"\"Get the current correlation ID for request tracing.\"\"\"\n    return _correlation_id.get()\n</code></pre>"},{"location":"api-reference/logging/#holmes.logging.set_correlation_id","title":"set_correlation_id","text":"<pre><code>set_correlation_id(correlation_id: str) -&gt; None\n</code></pre> <p>Set the correlation ID for the current context.</p> Source code in <code>src/holmes/logging.py</code> <pre><code>def set_correlation_id(correlation_id: str) -&gt; None:\n    \"\"\"Set the correlation ID for the current context.\"\"\"\n    _correlation_id.set(correlation_id)\n</code></pre>"},{"location":"api-reference/logging/#holmes.logging.log_with_timing","title":"log_with_timing","text":"<pre><code>log_with_timing(func: Callable[P, R]) -&gt; Callable[P, R]\n</code></pre> <p>Decorator that logs function execution time.</p> <p>P7-LOG-04: Performance monitoring via timing decorator.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>Function to wrap with timing</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>Wrapped function that logs execution time</p> Source code in <code>src/holmes/logging.py</code> <pre><code>def log_with_timing(\n    func: Callable[P, R],\n) -&gt; Callable[P, R]:\n    \"\"\"\n    Decorator that logs function execution time.\n\n    P7-LOG-04: Performance monitoring via timing decorator.\n\n    Parameters\n    ----------\n    func : Callable\n        Function to wrap with timing\n\n    Returns\n    -------\n    Callable\n        Wrapped function that logs execution time\n    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; R:\n        start_time = time.perf_counter()\n        try:\n            result = func(*args, **kwargs)\n            return result\n        finally:\n            elapsed = time.perf_counter() - start_time\n            logger.debug(f\"{func.__name__} completed in {elapsed:.3f}s\")\n\n    return wrapper\n</code></pre>"},{"location":"api-reference/logging/#holmes.logging.log_exception","title":"log_exception","text":"<pre><code>log_exception(exc: Exception, message: str = 'An error occurred') -&gt; None\n</code></pre> <p>Log an exception with full stack trace.</p> <p>P7-LOG-01: Ensure exceptions are logged with stack traces.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>Exception</code> <p>The exception to log</p> required <code>message</code> <code>str</code> <p>Additional context message</p> <code>'An error occurred'</code> Source code in <code>src/holmes/logging.py</code> <pre><code>def log_exception(exc: Exception, message: str = \"An error occurred\") -&gt; None:\n    \"\"\"\n    Log an exception with full stack trace.\n\n    P7-LOG-01: Ensure exceptions are logged with stack traces.\n\n    Parameters\n    ----------\n    exc : Exception\n        The exception to log\n    message : str\n        Additional context message\n    \"\"\"\n    logger.exception(f\"{message}: {exc}\")\n</code></pre>"},{"location":"api-reference/validation/","title":"validation","text":"<p>Input validation utilities for HOLMES.</p> <p>This module provides pure validation functions for validating user input, configuration values, and data before processing.</p>"},{"location":"api-reference/validation/#holmes.validation.validate_date_format","title":"validate_date_format","text":"<pre><code>validate_date_format(date_str: str, format_str: str = '%Y-%m-%d') -&gt; datetime\n</code></pre> <p>Parse and validate a date string.</p> <p>Parameters:</p> Name Type Description Default <code>date_str</code> <code>str</code> <p>Date string to validate</p> required <code>format_str</code> <code>str</code> <p>Expected date format, defaults to \"%Y-%m-%d\"</p> <code>'%Y-%m-%d'</code> <p>Returns:</p> Type Description <code>datetime</code> <p>Parsed datetime object</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the date string doesn't match the expected format</p> Source code in <code>src/holmes/validation.py</code> <pre><code>def validate_date_format(\n    date_str: str, format_str: str = \"%Y-%m-%d\"\n) -&gt; datetime:\n    \"\"\"\n    Parse and validate a date string.\n\n    Parameters\n    ----------\n    date_str : str\n        Date string to validate\n    format_str : str\n        Expected date format, defaults to \"%Y-%m-%d\"\n\n    Returns\n    -------\n    datetime\n        Parsed datetime object\n\n    Raises\n    ------\n    ValueError\n        If the date string doesn't match the expected format\n    \"\"\"\n    try:\n        return datetime.strptime(date_str, format_str)\n    except ValueError as exc:\n        raise ValueError(\n            f\"Invalid date format '{date_str}'. Expected format: {format_str}\"\n        ) from exc\n</code></pre>"},{"location":"api-reference/validation/#holmes.validation.validate_date_range","title":"validate_date_range","text":"<pre><code>validate_date_range(start: str, end: str) -&gt; tuple[datetime, datetime]\n</code></pre> <p>Validate that start date is before end date.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>str</code> <p>Start date string in \"%Y-%m-%d\" format</p> required <code>end</code> <code>str</code> <p>End date string in \"%Y-%m-%d\" format</p> required <p>Returns:</p> Type Description <code>tuple[datetime, datetime]</code> <p>Tuple of (start_datetime, end_datetime)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dates are invalid format or start &gt;= end</p> Source code in <code>src/holmes/validation.py</code> <pre><code>def validate_date_range(start: str, end: str) -&gt; tuple[datetime, datetime]:\n    \"\"\"\n    Validate that start date is before end date.\n\n    Parameters\n    ----------\n    start : str\n        Start date string in \"%Y-%m-%d\" format\n    end : str\n        End date string in \"%Y-%m-%d\" format\n\n    Returns\n    -------\n    tuple[datetime, datetime]\n        Tuple of (start_datetime, end_datetime)\n\n    Raises\n    ------\n    ValueError\n        If dates are invalid format or start &gt;= end\n    \"\"\"\n    start_dt = validate_date_format(start)\n    end_dt = validate_date_format(end)\n\n    if start_dt &gt;= end_dt:\n        raise ValueError(\n            f\"Start date ({start}) must be before end date ({end})\"\n        )\n\n    return start_dt, end_dt\n</code></pre>"},{"location":"api-reference/validation/#holmes.validation.validate_catchment_exists","title":"validate_catchment_exists","text":"<pre><code>validate_catchment_exists(catchment: str) -&gt; None\n</code></pre> <p>Validate that a catchment data file exists.</p> <p>Parameters:</p> Name Type Description Default <code>catchment</code> <code>str</code> <p>Catchment name to validate</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the catchment data file doesn't exist</p> Source code in <code>src/holmes/validation.py</code> <pre><code>def validate_catchment_exists(catchment: str) -&gt; None:\n    \"\"\"\n    Validate that a catchment data file exists.\n\n    Parameters\n    ----------\n    catchment : str\n        Catchment name to validate\n\n    Raises\n    ------\n    ValueError\n        If the catchment data file doesn't exist\n    \"\"\"\n    path = data_dir / f\"{catchment}_Observations.csv\"\n    if not path.exists():\n        available = sorted(\n            f.stem.replace(\"_Observations\", \"\")\n            for f in data_dir.glob(\"*_Observations.csv\")\n        )\n        raise ValueError(\n            f\"Catchment '{catchment}' not found. \"\n            f\"Available catchments: {', '.join(available)}\"\n        )\n</code></pre>"},{"location":"api-reference/validation/#holmes.validation.validate_port","title":"validate_port","text":"<pre><code>validate_port(port: int) -&gt; int\n</code></pre> <p>Validate that a port number is in the valid range.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>Port number to validate</p> required <p>Returns:</p> Type Description <code>int</code> <p>The validated port number</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If port is not in range 1-65535</p> Source code in <code>src/holmes/validation.py</code> <pre><code>def validate_port(port: int) -&gt; int:\n    \"\"\"\n    Validate that a port number is in the valid range.\n\n    Parameters\n    ----------\n    port : int\n        Port number to validate\n\n    Returns\n    -------\n    int\n        The validated port number\n\n    Raises\n    ------\n    ValueError\n        If port is not in range 1-65535\n    \"\"\"\n    if not 1 &lt;= port &lt;= 65535:\n        raise ValueError(f\"Port {port} is invalid. Must be in range 1-65535\")\n    return port\n</code></pre>"},{"location":"api-reference/validation/#holmes.validation.validate_host","title":"validate_host","text":"<pre><code>validate_host(host: str) -&gt; str\n</code></pre> <p>Validate that a host is a valid IP address or hostname.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Host string to validate (IP address or hostname)</p> required <p>Returns:</p> Type Description <code>str</code> <p>The validated host string</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If host is not a valid IP address or hostname</p> Source code in <code>src/holmes/validation.py</code> <pre><code>def validate_host(host: str) -&gt; str:\n    \"\"\"\n    Validate that a host is a valid IP address or hostname.\n\n    Parameters\n    ----------\n    host : str\n        Host string to validate (IP address or hostname)\n\n    Returns\n    -------\n    str\n        The validated host string\n\n    Raises\n    ------\n    ValueError\n        If host is not a valid IP address or hostname\n    \"\"\"\n    # Try as IP address first\n    try:\n        ipaddress.ip_address(host)\n        return host\n    except ValueError:\n        pass\n\n    # Check if it looks like an IP address (all numeric parts separated by dots)\n    # If so, reject it since it failed IP validation above\n    ip_like_pattern = re.compile(r\"^\\d{1,3}(\\.\\d{1,3}){3}$\")\n    if ip_like_pattern.match(host):\n        raise ValueError(\n            f\"Invalid host '{host}'. Must be a valid IP address or hostname\"\n        )\n\n    # Validate as hostname\n    # RFC 1123 hostname pattern\n    hostname_pattern = re.compile(\n        r\"^(?!-)[A-Za-z0-9-]{1,63}(?&lt;!-)$\"\n        r\"|^(?!-)[A-Za-z0-9-]{1,63}(?&lt;!-)(\\.[A-Za-z0-9-]{1,63}(?&lt;!-))*$\"\n    )\n    if hostname_pattern.match(host):\n        return host\n\n    raise ValueError(\n        f\"Invalid host '{host}'. Must be a valid IP address or hostname\"\n    )\n</code></pre>"},{"location":"api-reference/validation/#holmes.validation.validate_array_no_nan","title":"validate_array_no_nan","text":"<pre><code>validate_array_no_nan(arr: NDArray[floating], name: str) -&gt; None\n</code></pre> <p>Validate that an array contains no NaN or infinity values.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>ndarray</code> <p>Array to validate</p> required <code>name</code> <code>str</code> <p>Name of the array for error messages</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the array contains NaN or infinity values</p> Source code in <code>src/holmes/validation.py</code> <pre><code>def validate_array_no_nan(arr: npt.NDArray[np.floating], name: str) -&gt; None:\n    \"\"\"\n    Validate that an array contains no NaN or infinity values.\n\n    Parameters\n    ----------\n    arr : np.ndarray\n        Array to validate\n    name : str\n        Name of the array for error messages\n\n    Raises\n    ------\n    ValueError\n        If the array contains NaN or infinity values\n    \"\"\"\n    if not np.isfinite(arr).all():\n        nan_indices = np.where(~np.isfinite(arr))[0]\n        raise ValueError(\n            f\"Array '{name}' contains NaN or infinity values at indices: \"\n            f\"{nan_indices[:5].tolist()}{'...' if len(nan_indices) &gt; 5 else ''}\"\n        )\n</code></pre>"},{"location":"api-reference/validation/#holmes.validation.validate_array_length","title":"validate_array_length","text":"<pre><code>validate_array_length(arr: NDArray, expected: int, name: str) -&gt; None\n</code></pre> <p>Validate that an array has the expected length.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>ndarray</code> <p>Array to validate</p> required <code>expected</code> <code>int</code> <p>Expected length</p> required <code>name</code> <code>str</code> <p>Name of the array for error messages</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the array length doesn't match expected</p> Source code in <code>src/holmes/validation.py</code> <pre><code>def validate_array_length(arr: npt.NDArray, expected: int, name: str) -&gt; None:\n    \"\"\"\n    Validate that an array has the expected length.\n\n    Parameters\n    ----------\n    arr : np.ndarray\n        Array to validate\n    expected : int\n        Expected length\n    name : str\n        Name of the array for error messages\n\n    Raises\n    ------\n    ValueError\n        If the array length doesn't match expected\n    \"\"\"\n    if len(arr) != expected:\n        raise ValueError(\n            f\"Array '{name}' has length {len(arr)}, expected {expected}\"\n        )\n</code></pre>"},{"location":"api-reference/validation/#holmes.validation.validate_parameter_bounds","title":"validate_parameter_bounds","text":"<pre><code>validate_parameter_bounds(\n    params: NDArray[floating],\n    bounds: Sequence[tuple[float, float]],\n    names: Sequence[str],\n) -&gt; None\n</code></pre> <p>Validate that parameters fall within their defined bounds.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>ndarray</code> <p>Parameter values to validate</p> required <code>bounds</code> <code>Sequence[tuple[float, float]]</code> <p>List of (lower, upper) bounds for each parameter</p> required <code>names</code> <code>Sequence[str]</code> <p>Names of parameters for error messages</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If any parameter is outside its bounds</p> Source code in <code>src/holmes/validation.py</code> <pre><code>def validate_parameter_bounds(\n    params: npt.NDArray[np.floating],\n    bounds: Sequence[tuple[float, float]],\n    names: Sequence[str],\n) -&gt; None:\n    \"\"\"\n    Validate that parameters fall within their defined bounds.\n\n    Parameters\n    ----------\n    params : np.ndarray\n        Parameter values to validate\n    bounds : Sequence[tuple[float, float]]\n        List of (lower, upper) bounds for each parameter\n    names : Sequence[str]\n        Names of parameters for error messages\n\n    Raises\n    ------\n    ValueError\n        If any parameter is outside its bounds\n    \"\"\"\n    for value, (lower, upper), name in zip(params, bounds, names, strict=True):\n        if not lower &lt;= value &lt;= upper:\n            raise ValueError(\n                f\"Parameter '{name}' value {value} is outside bounds \"\n                f\"[{lower}, {upper}]\"\n            )\n</code></pre>"},{"location":"api-reference/validation/#holmes.validation.validate_ws_message_keys","title":"validate_ws_message_keys","text":"<pre><code>validate_ws_message_keys(\n    msg: dict, required_keys: Sequence[str], context: str = \"message\"\n) -&gt; None\n</code></pre> <p>Validate that a WebSocket message contains all required keys.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>dict</code> <p>Message dictionary to validate</p> required <code>required_keys</code> <code>Sequence[str]</code> <p>List of required keys</p> required <code>context</code> <code>str</code> <p>Context string for error messages</p> <code>'message'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any required keys are missing</p> Source code in <code>src/holmes/validation.py</code> <pre><code>def validate_ws_message_keys(\n    msg: dict, required_keys: Sequence[str], context: str = \"message\"\n) -&gt; None:\n    \"\"\"\n    Validate that a WebSocket message contains all required keys.\n\n    Parameters\n    ----------\n    msg : dict\n        Message dictionary to validate\n    required_keys : Sequence[str]\n        List of required keys\n    context : str\n        Context string for error messages\n\n    Raises\n    ------\n    ValueError\n        If any required keys are missing\n    \"\"\"\n    missing = [key for key in required_keys if key not in msg]\n    if missing:\n        raise ValueError(\n            f\"Missing required keys in {context}: {', '.join(missing)}\"\n        )\n</code></pre>"},{"location":"api-reference/api/","title":"api","text":"<p>HTTP and WebSocket route handlers for the HOLMES web application.</p>"},{"location":"api-reference/api/#modules","title":"Modules","text":"<ul> <li>api - Main router</li> <li>calibration - Calibration WebSocket handler</li> <li>simulation - Simulation routes</li> <li>projection - Projection routes</li> <li>utils - API utilities</li> </ul>"},{"location":"api-reference/api/api/","title":"api.api","text":""},{"location":"api-reference/api/calibration/","title":"api.calibration","text":""},{"location":"api-reference/api/calibration/#holmes.api.calibration.get_routes","title":"get_routes","text":"<pre><code>get_routes() -&gt; list[BaseRoute]\n</code></pre> <p>Get routes for calibration WebSocket endpoint.</p> Source code in <code>src/holmes/api/calibration.py</code> <pre><code>def get_routes() -&gt; list[BaseRoute]:\n    \"\"\"Get routes for calibration WebSocket endpoint.\"\"\"\n    return [\n        WebSocketRoute(\"/\", endpoint=_websocket_handler),\n    ]\n</code></pre>"},{"location":"api-reference/api/projection/","title":"api.projection","text":""},{"location":"api-reference/api/simulation/","title":"api.simulation","text":""},{"location":"api-reference/api/utils/","title":"api.utils","text":""},{"location":"api-reference/models/","title":"models","text":"<p>Model orchestration layer that dispatches to the Rust extension for computation.</p>"},{"location":"api-reference/models/#modules","title":"Modules","text":"<ul> <li>hydro - Hydrological models</li> <li>snow - Snow models</li> <li>calibration - Calibration orchestration</li> <li>utils - Model utilities</li> </ul>"},{"location":"api-reference/models/calibration/","title":"models.calibration","text":"<p>Calibration model registry and orchestration.</p> <p>This module provides calibration algorithms (SCE-UA) and orchestrates the calibration process using snow and hydro models.</p>"},{"location":"api-reference/models/calibration/#holmes.models.calibration.get_config","title":"get_config","text":"<pre><code>get_config(\n    model: Algorithm,\n) -&gt; list[dict[str, str | int | float | bool | None]]\n</code></pre> <p>Get calibration algorithm configuration.</p> Source code in <code>src/holmes/models/calibration.py</code> <pre><code>def get_config(\n    model: Algorithm,\n) -&gt; list[dict[str, str | int | float | bool | None]]:\n    \"\"\"Get calibration algorithm configuration.\"\"\"\n    match model:\n        case \"sce\":\n            return [\n                {\n                    \"name\": \"n_complexes\",\n                    \"min\": 1,\n                    \"max\": None,\n                    \"default\": 25,\n                    \"integer\": True,\n                },\n                {\n                    \"name\": \"k_stop\",\n                    \"min\": 1,\n                    \"max\": None,\n                    \"default\": 10,\n                    \"integer\": True,\n                },\n                {\n                    \"name\": \"p_convergence_threshold\",\n                    \"min\": 0,\n                    \"max\": 1,\n                    \"default\": 0.1,\n                    \"integer\": False,\n                },\n                {\n                    \"name\": \"geometric_range_threshold\",\n                    \"min\": 0,\n                    \"max\": None,\n                    \"default\": 0.001,\n                    \"integer\": False,\n                },\n                {\n                    \"name\": \"max_evaluations\",\n                    \"min\": 1,\n                    \"max\": None,\n                    \"default\": 5000,\n                    \"integer\": True,\n                },\n            ]\n        case _:  # pragma: no cover\n            assert_never(model)\n</code></pre>"},{"location":"api-reference/models/hydro/","title":"models.hydro","text":"<p>Hydrological model registry.</p> <p>This module provides access to hydrological models implemented in the holmes_rs Rust extension.</p>"},{"location":"api-reference/models/hydro/#holmes.models.hydro.get_config","title":"get_config","text":"<pre><code>get_config(model: HydroModel) -&gt; list[dict[str, str | float]]\n</code></pre> <p>Get model parameter configuration.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>HydroModel</code> <p>Model name (see HydroModel for valid options)</p> required <p>Returns:</p> Type Description <code>list[dict]</code> <p>List of parameter configurations with name, default, min, max</p> Source code in <code>src/holmes/models/hydro.py</code> <pre><code>def get_config(model: HydroModel) -&gt; list[dict[str, str | float]]:\n    \"\"\"\n    Get model parameter configuration.\n\n    Parameters\n    ----------\n    model : HydroModel\n        Model name (see HydroModel for valid options)\n\n    Returns\n    -------\n    list[dict]\n        List of parameter configurations with name, default, min, max\n    \"\"\"\n    try:\n        match model:\n            case \"gr4j\":\n                param_names = gr4j.param_names\n                defaults, bounds = gr4j.init()\n            case \"bucket\":\n                param_names = bucket.param_names\n                defaults, bounds = bucket.init()\n            case \"cequeau\":\n                param_names = cequeau.param_names\n                defaults, bounds = cequeau.init()\n            case _:  # pragma: no cover\n                assert_never(model)  # type: ignore\n    except (HolmesNumericalError, HolmesValidationError) as exc:\n        logger.error(f\"Failed to initialize {model} model: {exc}\")\n        raise\n    except Exception as exc:  # pragma: no cover\n        logger.exception(f\"Unexpected error initializing {model} model\")\n        raise HolmesError(f\"Failed to initialize model: {exc}\") from exc\n\n    return [\n        {\n            \"name\": name,\n            \"default\": default,\n            \"min\": bounds_[0],\n            \"max\": bounds_[1],\n        }\n        for name, default, bounds_ in zip(param_names, defaults, bounds)\n    ]\n</code></pre>"},{"location":"api-reference/models/hydro/#holmes.models.hydro.get_model","title":"get_model","text":"<pre><code>get_model(\n    model: HydroModel,\n) -&gt; Callable[\n    [NDArray[float64], NDArray[float64], NDArray[float64]], NDArray[float64]\n]\n</code></pre> <p>Get a wrapped model simulation function.</p> <p>The returned function wraps the underlying Rust implementation with error handling and logging.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>HydroModel</code> <p>Model name (see HydroModel for valid options)</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>Simulation function that takes (params, precipitation, pet) and returns streamflow</p> Source code in <code>src/holmes/models/hydro.py</code> <pre><code>def get_model(\n    model: HydroModel,\n) -&gt; Callable[\n    [\n        npt.NDArray[np.float64],\n        npt.NDArray[np.float64],\n        npt.NDArray[np.float64],\n    ],\n    npt.NDArray[np.float64],\n]:\n    \"\"\"\n    Get a wrapped model simulation function.\n\n    The returned function wraps the underlying Rust implementation\n    with error handling and logging.\n\n    Parameters\n    ----------\n    model : HydroModel\n        Model name (see HydroModel for valid options)\n\n    Returns\n    -------\n    Callable\n        Simulation function that takes (params, precipitation, pet)\n        and returns streamflow\n    \"\"\"\n    match model:\n        case \"gr4j\":\n            simulate_fn = gr4j.simulate\n        case \"bucket\":\n            simulate_fn = bucket.simulate\n        case \"cequeau\":\n            simulate_fn = cequeau.simulate\n        case _:  # pragma: no cover\n            assert_never(model)  # type: ignore\n\n    def wrapped_simulate(\n        params: npt.NDArray[np.float64],\n        precipitation: npt.NDArray[np.float64],\n        pet: npt.NDArray[np.float64],\n    ) -&gt; npt.NDArray[np.float64]:\n        \"\"\"Wrapped simulation function with error handling.\"\"\"\n        try:\n            return simulate_fn(params, precipitation, pet)\n        except (HolmesNumericalError, HolmesValidationError) as exc:\n            logger.error(f\"Simulation failed for {model}: {exc}\")\n            raise\n        except Exception as exc:  # pragma: no cover\n            logger.exception(f\"Unexpected error in {model} simulation\")\n            raise HolmesError(f\"Simulation failed: {exc}\") from exc\n\n    return wrapped_simulate\n</code></pre>"},{"location":"api-reference/models/snow/","title":"models.snow","text":"<p>Snow model registry.</p> <p>This module provides access to snow models implemented in the holmes_rs Rust extension.</p>"},{"location":"api-reference/models/snow/#holmes.models.snow.get_model","title":"get_model","text":"<pre><code>get_model(\n    model: SnowModel,\n) -&gt; Callable[\n    [\n        NDArray[float64],\n        NDArray[float64],\n        NDArray[float64],\n        NDArray[uintp],\n        NDArray[float64],\n        float,\n    ],\n    NDArray[float64],\n]\n</code></pre> <p>Get a wrapped snow model simulation function.</p> <p>The returned function wraps the underlying Rust implementation with error handling and logging.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>SnowModel</code> <p>Model name (see SnowModel for valid options)</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>Simulation function that takes precipitation, temperature, params, day_of_year, altitude_layers, and median_altitude, and returns adjusted precipitation</p> Source code in <code>src/holmes/models/snow.py</code> <pre><code>def get_model(\n    model: SnowModel,\n) -&gt; Callable[\n    [\n        npt.NDArray[np.float64],  # params\n        npt.NDArray[np.float64],  # precipitation\n        npt.NDArray[np.float64],  # temperature\n        npt.NDArray[np.uintp],  # day_of_year\n        npt.NDArray[np.float64],  # altitude_layers\n        float,  # median_altitude\n    ],\n    npt.NDArray[np.float64],\n]:\n    \"\"\"\n    Get a wrapped snow model simulation function.\n\n    The returned function wraps the underlying Rust implementation\n    with error handling and logging.\n\n    Parameters\n    ----------\n    model : SnowModel\n        Model name (see SnowModel for valid options)\n\n    Returns\n    -------\n    Callable\n        Simulation function that takes precipitation, temperature, params,\n        day_of_year, altitude_layers, and median_altitude,\n        and returns adjusted precipitation\n    \"\"\"\n    match model:\n        case \"cemaneige\":\n            simulate_fn = cemaneige.simulate\n        case _:  # pragma: no cover\n            assert_never(model)\n\n    def wrapped_simulate(\n        params: npt.NDArray[np.float64],\n        precipitation: npt.NDArray[np.float64],\n        temperature: npt.NDArray[np.float64],\n        day_of_year: npt.NDArray[np.uintp],\n        altitude_layers: npt.NDArray[np.float64],\n        median_altitude: float,\n    ) -&gt; npt.NDArray[np.float64]:\n        \"\"\"Wrapped snow simulation function with error handling.\"\"\"\n        try:\n            return simulate_fn(\n                params,\n                precipitation,\n                temperature,\n                day_of_year,\n                altitude_layers,\n                median_altitude,\n            )\n        except (HolmesNumericalError, HolmesValidationError) as exc:\n            logger.error(f\"Snow simulation failed for {model}: {exc}\")\n            raise\n        except Exception as exc:  # pragma: no cover\n            logger.exception(f\"Unexpected error in {model} snow simulation\")\n            raise HolmesError(f\"Snow simulation failed: {exc}\") from exc\n\n    return wrapped_simulate\n</code></pre>"},{"location":"api-reference/models/utils/","title":"models.utils","text":""},{"location":"api-reference/utils/","title":"utils","text":"<p>Utility functions for HOLMES.</p>"},{"location":"api-reference/utils/#modules","title":"Modules","text":"<ul> <li>paths - Path utilities</li> <li>print - Print utilities</li> <li>websocket - WebSocket utilities</li> </ul>"},{"location":"api-reference/utils/paths/","title":"utils.paths","text":""},{"location":"api-reference/utils/print/","title":"utils.print","text":""},{"location":"api-reference/utils/websocket/","title":"utils.websocket","text":""},{"location":"api-reference/utils/websocket/#holmes.utils.websocket.safe_send","title":"safe_send  <code>async</code>","text":"<pre><code>safe_send(ws: WebSocket, event: str, data: Any) -&gt; bool\n</code></pre> <p>Safely send a message through WebSocket with error handling.</p> <p>Parameters:</p> Name Type Description Default <code>ws</code> <code>WebSocket</code> <p>The WebSocket connection</p> required <code>event</code> <code>str</code> <p>Event type for the message</p> required <code>data</code> <code>Any</code> <p>Data to send (will be converted to JSON-safe format)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if message was sent successfully, False otherwise</p> Source code in <code>src/holmes/utils/websocket.py</code> <pre><code>async def safe_send(ws: WebSocket, event: str, data: Any) -&gt; bool:\n    \"\"\"\n    Safely send a message through WebSocket with error handling.\n\n    Parameters\n    ----------\n    ws : WebSocket\n        The WebSocket connection\n    event : str\n        Event type for the message\n    data : Any\n        Data to send (will be converted to JSON-safe format)\n\n    Returns\n    -------\n    bool\n        True if message was sent successfully, False otherwise\n    \"\"\"\n    if ws.client_state != WebSocketState.CONNECTED:\n        logger.debug(f\"Cannot send '{event}': WebSocket not connected\")\n        return False\n\n    try:\n        await ws.send_json({\"type\": event, \"data\": convert_for_json(data)})\n        return True\n    except RuntimeError as exc:\n        # Connection closed during send\n        logger.debug(f\"Failed to send '{event}': {exc}\")\n        return False\n    except Exception as exc:  # pragma: no cover\n        logger.warning(f\"Unexpected error sending '{event}': {exc}\")\n        return False\n</code></pre>"},{"location":"concepts/","title":"Concepts","text":"<p>This section introduces the fundamental concepts behind rainfall-runoff modeling and explains the hydrological models, algorithms, and metrics implemented in HOLMES.</p>"},{"location":"concepts/#what-is-rainfall-runoff-modeling","title":"What is Rainfall-Runoff Modeling?","text":"<p>Rainfall-runoff modeling is the process of simulating how precipitation falling on a catchment transforms into streamflow at the outlet. This transformation involves complex physical processes: water infiltrates into the soil, evaporates back to the atmosphere, percolates to groundwater, and eventually reaches the stream through various pathways. A rainfall-runoff model attempts to represent these processes mathematically, allowing us to predict streamflow from meteorological inputs.</p> <p>Understanding these models is essential for water resources management, flood forecasting, drought assessment, and infrastructure design. Rather than solving the full physics of water movement through soil and aquifers (which would require detailed spatial data rarely available), conceptual models use simplified representations that capture the essential behavior of catchment hydrology.</p>"},{"location":"concepts/#the-water-balance-concept","title":"The Water Balance Concept","text":"<p>At its core, hydrological modeling relies on the water balance equation:</p> \\[\\frac{dS}{dt} = P - E - Q\\] <p>where:</p> <ul> <li>\\(S\\) is the water stored in the catchment (soil moisture, groundwater, snow)</li> <li>\\(P\\) is precipitation (rain and snow)</li> <li>\\(E\\) is evapotranspiration (water returning to the atmosphere)</li> <li>\\(Q\\) is streamflow at the outlet</li> </ul> <p>This simple equation states that changes in storage equal inputs minus outputs. All conceptual hydrological models are elaborations of this principle, adding reservoirs, pathways, and time delays to represent how water moves through the system.</p>"},{"location":"concepts/#the-holmes-modeling-chain","title":"The HOLMES Modeling Chain","text":"<p>HOLMES implements a complete modeling chain for rainfall-runoff simulation. Each step builds on the previous one:</p>"},{"location":"concepts/#1-potential-evapotranspiration-pet","title":"1. Potential Evapotranspiration (PET)","text":"<p>Before running a hydrological model, we need to estimate the atmospheric demand for water. PET represents the maximum amount of water that would evaporate and transpire if water were unlimited. HOLMES uses the Oudin method, which estimates PET from temperature and solar radiation alone, making it practical when detailed meteorological data are unavailable.</p>"},{"location":"concepts/#2-snow-accumulation-and-melt","title":"2. Snow Accumulation and Melt","text":"<p>In catchments with significant snowfall, precipitation does not immediately contribute to runoff. Snow accumulates during cold periods and releases water during melt, fundamentally altering the timing of streamflow. The CemaNeige model tracks snowpack evolution using a degree-day approach, partitioning precipitation between rain and snow and calculating melt based on temperature.</p>"},{"location":"concepts/#3-hydrological-transformation","title":"3. Hydrological Transformation","text":"<p>The core of the modeling chain is the rainfall-runoff model that transforms effective precipitation (rainfall plus snowmelt) into streamflow. HOLMES implements two models:</p> <ul> <li>GR4J: A parsimonious four-parameter model widely used in research and operations. It represents the catchment as two stores (production and routing) connected by unit hydrographs.</li> <li>Bucket model: A six-parameter model based on linear reservoir theory with explicit fast and slow flow paths. Offers more flexibility in flow partitioning and often captures recession behavior well.</li> </ul>"},{"location":"concepts/#4-model-calibration","title":"4. Model Calibration","text":"<p>Hydrological models have parameters that cannot be measured directly and must be estimated by comparing model outputs to observed streamflow. This process, called calibration, searches for parameter values that minimize the difference between simulated and observed flows. HOLMES uses the SCE-UA algorithm, a global optimization method designed specifically for hydrological model calibration.</p>"},{"location":"concepts/#5-performance-evaluation","title":"5. Performance Evaluation","text":"<p>After calibration, we need to assess how well the model performs. HOLMES provides several performance metrics that quantify different aspects of model accuracy:</p> <ul> <li>RMSE measures average error magnitude</li> <li>NSE measures skill relative to using the mean as a predictor</li> <li>KGE decomposes performance into correlation, variability bias, and mean bias</li> </ul>"},{"location":"concepts/#choosing-the-right-model","title":"Choosing the Right Model","text":"<p>The choice of model depends on your catchment characteristics and objectives:</p> Consideration GR4J Bucket Model Parameters 4 6 Flow partitioning Fixed (90%/10%) Calibratable (\\(\\alpha\\), \\(\\beta\\)) Routing Unit hydrographs + nonlinear store Linear reservoirs Groundwater exchange Yes (\\(X_2\\) parameter) No Equifinality risk Lower Higher Best for Humid temperate catchments, benchmarking Catchments with distinct recession components <p>For catchments with significant snow, enable CemaNeige regardless of which hydrological model you choose.</p>"},{"location":"concepts/#further-reading","title":"Further Reading","text":"<p>Each concept page provides detailed explanations, mathematical formulations, and practical guidance:</p> <ul> <li>GR4J Model - Parsimonious four-parameter model</li> <li>Bucket Model - Linear reservoir model with flexible flow partitioning</li> <li>Snow Models (CemaNeige) - Snow accumulation and melt</li> <li>PET Models (Oudin) - Potential evapotranspiration calculation</li> <li>Calibration Algorithms (SCE-UA) - Automatic parameter optimization</li> <li>Performance Metrics - RMSE, NSE, and KGE explained</li> </ul>"},{"location":"concepts/bucket/","title":"Bucket Model","text":""},{"location":"concepts/bucket/#overview","title":"Overview","text":"<p>The bucket model is a conceptual rainfall-runoff model based on the linear reservoir framework. It represents a catchment using interconnected \"buckets\" or reservoirs: a soil moisture store that controls evaporation, and two routing stores that produce slow (baseflow) and fast (quickflow) components of streamflow.</p> <p>The model's modular structure explicitly separates different flow pathways, making it straightforward to understand how each component contributes to the total hydrograph. With six parameters, the bucket model offers more flexibility than GR4J in representing flow partitioning and recession behavior, though this comes with increased risk of parameter equifinality.</p> <p>Bucket-style models (also called tank models) have a long history in hydrology and remain widely used. The explicit linear reservoir structure often captures recession dynamics well, particularly in catchments with distinct baseflow and quickflow components.</p>"},{"location":"concepts/bucket/#key-concepts","title":"Key Concepts","text":"<ul> <li> <p>Soil moisture store: The primary reservoir that receives precipitation and loses water to evapotranspiration. When full, excess water drains to the routing stores.</p> </li> <li> <p>Linear reservoir: A fundamental concept in hydrology where outflow is proportional to storage. The constant of proportionality is the recession coefficient \\(K\\), representing the time for storage to decrease to \\(1/e\\) (about 37%) of its initial value.</p> </li> <li> <p>Baseflow (slow flow): The sustained flow that continues long after rainfall stops, fed by gradual drainage from soil and groundwater. Characterized by a long recession time constant.</p> </li> <li> <p>Quickflow (fast flow): The rapid response to rainfall that produces flood peaks. Represents surface runoff and fast subsurface flow paths.</p> </li> <li> <p>Routing delay: The time required for water to travel from the catchment to the outlet, implemented as a simple translation of the hydrograph.</p> </li> </ul>"},{"location":"concepts/bucket/#how-it-works","title":"How It Works","text":"<p>The bucket model processes precipitation and evapotranspiration through the following steps:</p> <p>Step 1: Precipitation partitioning. Incoming precipitation splits between water that enters the soil store and water that bypasses it entirely (direct runoff). The parameter \\(\\beta\\) controls this split.</p> <p>Step 2: Soil moisture accounting. Water entering the soil store is subject to evapotranspiration. During wet periods (precipitation exceeds PET), the store fills up. When the store exceeds its capacity \\(C_{soil}\\), the excess becomes infiltration. During dry periods (PET exceeds precipitation), the store depletes exponentially.</p> <p>Step 3: Infiltration partitioning. Water that infiltrates below the soil store splits between the slow store (becoming baseflow) and the fast store (becoming quickflow). The parameter \\(\\alpha\\) controls this split.</p> <p>Step 4: Linear reservoir outflow. Each routing store releases water at a rate proportional to its content. The slow store uses time constant \\(K_r\\), while the fast store uses \\(K_t\\).</p> <p>Step 5: Routing delay. The combined outflow is delayed by \\(\\delta\\) days to account for channel routing, using linear interpolation between adjacent time steps.</p>"},{"location":"concepts/bucket/#parameters","title":"Parameters","text":"<p>The bucket model has six calibratable parameters:</p> Parameter Description Range Units Physical Interpretation \\(C_{soil}\\) Soil moisture capacity 10\u20131000 mm Maximum water storage in the soil. Larger values allow more water retention before runoff occurs. \\(\\alpha\\) Infiltration split ratio 0\u20131 - Fraction of infiltration going to the slow store. Higher values produce more baseflow-dominated hydrographs. \\(K_r\\) Slow recession constant 1\u2013200 days Time scale for baseflow depletion. Larger values produce slower, more sustained baseflow. \\(\\delta\\) Routing delay 2\u201310 days Translation time for flow to reach the outlet. Reflects channel length and velocity. \\(\\beta\\) Direct runoff fraction 0\u20131 - Fraction of precipitation bypassing the soil store. Higher values produce flashier response. \\(K_t\\) Fast recession constant 1\u2013400 days Time scale for quickflow depletion. Typically much smaller than \\(K_r\\). <p>Understanding the parameters:</p> <ul> <li>\\(C_{soil}\\) acts like the soil depth times porosity\u2014how much water can the soil hold before it overflows?</li> <li>\\(\\alpha\\) and \\(\\beta\\) together control the shape of the hydrograph. High \\(\\beta\\) and low \\(\\alpha\\) produce flashy, peaked responses; low \\(\\beta\\) and high \\(\\alpha\\) produce subdued, baseflow-dominated responses.</li> <li>\\(K_r\\) and \\(K_t\\) control how quickly the catchment \"forgets\" past rainfall. A stream with \\(K_r = 100\\) days will have baseflow lasting months after rainfall stops.</li> <li>\\(\\delta\\) is primarily a timing parameter\u2014it shifts the entire hydrograph but doesn't change its shape.</li> </ul>"},{"location":"concepts/bucket/#mathematical-formulation","title":"Mathematical Formulation","text":""},{"location":"concepts/bucket/#initialization","title":"Initialization","text":"<p>Initial store levels:</p> \\[S_0 = 0.5 \\cdot C_{soil}, \\quad R_0 = 10, \\quad T_0 = 5\\] <p>where \\(S\\) is soil moisture, \\(R\\) is the slow routing store, and \\(T\\) is the fast routing store.</p>"},{"location":"concepts/bucket/#precipitation-partitioning","title":"Precipitation Partitioning","text":"<p>Precipitation \\(P\\) splits into soil input and direct fast flow:</p> \\[P_s = (1 - \\beta) \\cdot P\\] \\[P_r = \\beta \\cdot P\\] <p>where \\(P_s\\) enters the soil store and \\(P_r\\) goes directly to the fast routing store.</p>"},{"location":"concepts/bucket/#soil-moisture-dynamics","title":"Soil Moisture Dynamics","text":"<p>Wet conditions (\\(P_s \\geq E\\)):</p> <p>When precipitation input exceeds evapotranspiration demand:</p> \\[S \\leftarrow S + P_s - E\\] <p>Any excess above capacity becomes infiltration:</p> \\[I_s = \\max(S - C_{soil}, 0)\\] \\[S \\leftarrow S - I_s\\] <p>Dry conditions (\\(P_s &lt; E\\)):</p> <p>When evapotranspiration demand exceeds precipitation input, the store depletes exponentially:</p> \\[S \\leftarrow S \\cdot \\exp\\left(\\frac{P_s - E}{C_{soil}}\\right)\\] <p>This formulation ensures that evaporation decreases as the soil dries (water-limited evaporation).</p>"},{"location":"concepts/bucket/#infiltration-partitioning","title":"Infiltration Partitioning","text":"<p>Infiltration from the soil store splits between routing stores:</p> \\[I_{slow} = (1 - \\alpha) \\cdot I_s\\] \\[I_{fast} = \\alpha \\cdot I_s\\]"},{"location":"concepts/bucket/#routing-stores","title":"Routing Stores","text":"<p>Both routing stores follow linear reservoir dynamics.</p> <p>Slow store (baseflow):</p> \\[R \\leftarrow R + I_{slow}\\] \\[Q_r = \\frac{R}{K_r}\\] \\[R \\leftarrow R - Q_r\\] <p>Fast store (quickflow):</p> \\[T \\leftarrow T + P_r + I_{fast}\\] \\[Q_t = \\frac{T}{K_t}\\] \\[T \\leftarrow T - Q_t\\]"},{"location":"concepts/bucket/#total-system-outflow","title":"Total System Outflow","text":"\\[Q_{sys} = Q_r + Q_t\\]"},{"location":"concepts/bucket/#routing-delay","title":"Routing Delay","text":"<p>The routing delay is implemented using linear interpolation. For a delay of \\(\\delta\\) days, the model maintains a delay array and shifts flows forward:</p> \\[Q(t) = \\text{delayed}(Q_{sys}, \\delta)\\] <p>The delay uses linear interpolation when \\(\\delta\\) is not an integer, distributing water between adjacent time steps.</p>"},{"location":"concepts/bucket/#references","title":"References","text":"<p>Thornthwaite, C. W., &amp; Mather, J. R. (1955). The water balance. Publications in Climatology, 8(1). Drexel Institute of Technology, Laboratory of Climatology.</p> <p>Perrin, C. (2000). Vers une am\u00e9lioration d'un mod\u00e8le global pluie-d\u00e9bit  PhD Thesis, INPG Grenoble, Appendix 1, pp. 313-316. https://tel.archives-ouvertes.fr/tel-00006216</p>"},{"location":"concepts/calibration-algorithms/","title":"Calibration Algorithms","text":""},{"location":"concepts/calibration-algorithms/#sce-ua-shuffled-complex-evolution","title":"SCE-UA: Shuffled Complex Evolution","text":""},{"location":"concepts/calibration-algorithms/#overview","title":"Overview","text":"<p>Model calibration is the process of finding parameter values that make model outputs match observations as closely as possible. In rainfall-runoff modeling, this means adjusting parameters like soil capacity, recession rates, and routing times until simulated streamflow resembles observed streamflow.</p> <p>This is fundamentally an optimization problem: we seek parameter values that minimize (or maximize) an objective function measuring the discrepancy between simulations and observations. The challenge is that hydrological models have complex response surfaces with multiple local optima\u2014simple gradient-based methods often get trapped in suboptimal solutions.</p> <p>SCE-UA (Shuffled Complex Evolution - University of Arizona) is a global optimization algorithm specifically designed for hydrological model calibration. Developed by Duan, Sorooshian, and Gupta in the early 1990s, it has become the de facto standard for automatic calibration of conceptual rainfall-runoff models. SCE-UA combines elements from multiple optimization traditions to efficiently explore the parameter space and reliably find the global optimum.</p>"},{"location":"concepts/calibration-algorithms/#key-concepts","title":"Key Concepts","text":"<ul> <li> <p>Objective function: A mathematical measure of how well the model fits observations. Common choices include Nash-Sutcliffe Efficiency (NSE), Kling-Gupta Efficiency (KGE), or Root Mean Square Error (RMSE). The calibration algorithm tries to optimize this function.</p> </li> <li> <p>Parameter space: The multi-dimensional space defined by parameter bounds. For a 4-parameter model like GR4J, this is a 4-dimensional hypercube.</p> </li> <li> <p>Global vs. local optimization: Local methods find the nearest minimum; global methods search the entire space. Hydrological models need global methods because their response surfaces have many local minima.</p> </li> <li> <p>Population-based search: Rather than tracking a single solution, SCE-UA maintains a population of candidate solutions that collectively explore the parameter space.</p> </li> <li> <p>Complex: A subset of the population that evolves semi-independently. The \"shuffled\" aspect comes from periodically mixing complexes to share information.</p> </li> </ul>"},{"location":"concepts/calibration-algorithms/#how-sce-ua-works","title":"How SCE-UA Works","text":"<p>SCE-UA operates through an iterative process of evolution and shuffling:</p> <p>Step 1: Initialization. Generate a random population of parameter sets spanning the feasible parameter space. Evaluate the objective function for each.</p> <p>Step 2: Partition into complexes. Sort the population by objective function value and distribute points among complexes using a round-robin scheme. Each complex contains a mix of good and poor solutions.</p> <p>Step 3: Evolve each complex. Within each complex, repeatedly select a subset (simplex) of points and improve them using a modified Nelder-Mead procedure: - Select points favoring better solutions (using a triangular distribution) - Compute a reflection point that moves away from the worst solution - If reflection improves the solution, keep it - Otherwise, try contraction toward the centroid - If all else fails, generate a random point</p> <p>Step 4: Shuffle. Recombine all complexes into a single population, sort by objective function, and redistribute into new complexes. This allows information to spread between complexes.</p> <p>Step 5: Check convergence. Stop if: - Maximum function evaluations reached - Parameters have converged (all complexes found similar solutions) - Objective function is no longer improving</p> <p>Step 6: Repeat from Step 2 until convergence.</p>"},{"location":"concepts/calibration-algorithms/#algorithm-parameters","title":"Algorithm Parameters","text":"<p>SCE-UA has several algorithm parameters that control its behavior:</p> Parameter Description Typical Value Effect <code>n_complexes</code> Number of complexes 2\u20135 More complexes = more exploration, slower convergence <code>max_evaluations</code> Maximum function evaluations 5000\u201350000 Computational budget <code>geometric_range_threshold</code> Convergence criterion 0.001 Stop when parameters converge to this precision <code>p_convergence_threshold</code> Objective improvement threshold 0.1% Stop when improvement falls below this <code>k_stop</code> Number of iterations for improvement check 10 Window for assessing improvement <p>Choosing the number of complexes:</p> <ul> <li>For simple problems (4 parameters): 2\u20133 complexes</li> <li>For complex problems (7+ parameters): 4\u20135 complexes</li> <li>More complexes reduce risk of premature convergence but increase computation</li> </ul>"},{"location":"concepts/calibration-algorithms/#mathematical-details","title":"Mathematical Details","text":""},{"location":"concepts/calibration-algorithms/#population-structure","title":"Population Structure","text":"<p>For \\(n\\) model parameters, SCE-UA uses:</p> <ul> <li>Points per complex: \\(m = 2n + 1\\)</li> <li>Simplex size: \\(n + 1\\)</li> <li>Evolution steps per complex: \\(m\\)</li> <li>Total population: \\(p = m \\times n_{complexes}\\)</li> </ul>"},{"location":"concepts/calibration-algorithms/#simplex-selection","title":"Simplex Selection","text":"<p>Points within a complex are selected for the simplex using a triangular probability distribution that favors better solutions:</p> \\[L_{pos} = \\left\\lfloor (m + 0.5) - \\sqrt{(m + 0.5)^2 - m(m+1) \\cdot U} \\right\\rfloor\\] <p>where \\(U\\) is a uniform random number in \\([0, 1]\\). This gives higher probability to points with better objective values (lower indices in the sorted complex).</p>"},{"location":"concepts/calibration-algorithms/#simplex-evolution","title":"Simplex Evolution","text":"<p>The evolution step uses reflection and contraction coefficients:</p> <ul> <li>Reflection coefficient: \\(\\alpha = 1.0\\)</li> <li>Contraction coefficient: \\(\\beta = 0.5\\)</li> </ul> <p>Reflection:</p> \\[\\mathbf{x}_{reflect} = \\mathbf{c} + \\alpha(\\mathbf{c} - \\mathbf{x}_{worst})\\] <p>where \\(\\mathbf{c}\\) is the centroid of all simplex points except the worst.</p> <p>Contraction:</p> \\[\\mathbf{x}_{contract} = \\mathbf{x}_{worst} + \\beta(\\mathbf{c} - \\mathbf{x}_{worst})\\] <p>If both reflection and contraction fail to improve upon the worst point, a random point within parameter bounds is generated.</p>"},{"location":"concepts/calibration-algorithms/#convergence-criteria","title":"Convergence Criteria","text":"<p>Geometric normalized range (GNRNG):</p> \\[GNRNG = \\exp\\left(\\frac{1}{n}\\sum_{i=1}^{n} \\ln\\left(\\frac{range_i}{bounds_i}\\right)\\right)\\] <p>where \\(range_i\\) is the range of parameter \\(i\\) across the current population and \\(bounds_i\\) is the feasible range. Convergence when \\(GNRNG &lt; threshold\\).</p> <p>Percentage change criterion:</p> \\[\\Delta = \\frac{|f_t - f_{t-k}|}{\\bar{f}} \\times 100\\] <p>where \\(f_t\\) is the best objective value at iteration \\(t\\) and \\(\\bar{f}\\) is the mean of recent best values. Convergence when \\(\\Delta &lt; threshold\\).</p>"},{"location":"concepts/calibration-algorithms/#practical-considerations","title":"Practical Considerations","text":""},{"location":"concepts/calibration-algorithms/#before-calibration","title":"Before Calibration","text":"<ol> <li> <p>Define parameter bounds carefully. Bounds should be physically realistic but wide enough to allow exploration. Too narrow bounds may exclude the true optimum; too wide bounds waste computational effort.</p> </li> <li> <p>Choose an appropriate objective function. NSE emphasizes peak flows; KGE provides a more balanced assessment. Consider what aspects of the hydrograph matter most for your application.</p> </li> <li> <p>Use a warm-up period. The first year of simulation is often affected by initial conditions. Exclude it from the objective function calculation.</p> </li> <li> <p>Reserve data for validation. Don't use all your data for calibration. Keep some years aside to test whether the calibrated model generalizes.</p> </li> </ol>"},{"location":"concepts/calibration-algorithms/#during-calibration","title":"During Calibration","text":"<ol> <li>Monitor progress. Watch for:</li> <li>Steady improvement in objective function</li> <li>Parameters converging toward similar values</li> <li> <p>Adequate exploration of parameter space</p> </li> <li> <p>Be patient. Global optimization takes time. Premature stopping may miss better solutions.</p> </li> <li> <p>Multiple runs. Run calibration several times with different random seeds. If results differ substantially, the problem may have multiple optima.</p> </li> </ol>"},{"location":"concepts/calibration-algorithms/#interpreting-results","title":"Interpreting Results","text":"<ol> <li>Check parameter values. Parameters at or near bounds may indicate:</li> <li>Bounds are too restrictive</li> <li>Model structure is inappropriate</li> <li> <p>Data quality issues</p> </li> <li> <p>Examine residuals. Plot simulated vs. observed flows. Systematic patterns (e.g., always underpredicting peaks) suggest model structural limitations.</p> </li> <li> <p>Compare metrics. Calculate multiple performance metrics (RMSE, NSE, KGE) even if you only optimized one. This reveals trade-offs.</p> </li> <li> <p>Validate on independent data. Apply the calibrated model to data not used for calibration. Performance degradation indicates overfitting.</p> </li> </ol>"},{"location":"concepts/calibration-algorithms/#common-issues-and-solutions","title":"Common Issues and Solutions","text":"Issue Possible Causes Solutions Calibration never converges Bounds too wide, insufficient evaluations Narrow bounds, increase <code>max_evaluations</code> Different runs give different results Multiple local optima Increase <code>n_complexes</code>, run multiple times Parameters hit bounds Bounds too restrictive, data issues Widen bounds, check data quality Poor validation performance Overfitting, non-stationary catchment Use shorter calibration period, add regularization Very slow progress Too many parameters, expensive model Reduce complexity, use efficient implementation"},{"location":"concepts/calibration-algorithms/#transformation-options","title":"Transformation Options","text":"<p>HOLMES allows applying transformations to streamflow before computing the objective function:</p> Transformation Formula Effect None \\(Q' = Q\\) Equal weight to all flows Logarithmic \\(Q' = \\ln(Q)\\) Emphasizes low flows Square root \\(Q' = \\sqrt{Q}\\) Moderate emphasis on low flows <p>Log transformation is useful when you want the model to capture recession behavior accurately, not just peak flows.</p>"},{"location":"concepts/calibration-algorithms/#references","title":"References","text":"<p>Duan, Q., Sorooshian, S., &amp; Gupta, V. (1992). Effective and efficient global optimization for conceptual rainfall-runoff models. Water Resources Research, 28(4), 1015-1031. https://doi.org/10.1029/91WR02985</p> <p>The original SCE-UA paper, presenting the algorithm and demonstrating its effectiveness on the Sacramento Soil Moisture Accounting model.</p> <p>Duan, Q., Sorooshian, S., &amp; Gupta, V. K. (1994). Optimal use of the SCE-UA global optimization method for calibrating watershed models. Journal of Hydrology, 158(3-4), 265-284. https://doi.org/10.1016/0022-1694(94)90057-4</p> <p>A follow-up paper providing practical guidance on algorithm settings and convergence criteria.</p> <p>Nelder, J. A., &amp; Mead, R. (1965). A simplex method for function minimization. The Computer Journal, 7(4), 308-313.</p> <p>The original simplex algorithm that forms the basis for the complex evolution step in SCE-UA.</p>"},{"location":"concepts/cequeau/","title":"CEQUEAU Model","text":""},{"location":"concepts/cequeau/#overview","title":"Overview","text":"<p>CEQUEAU is a conceptual rainfall-runoff model originally developed at INRS-Eau (Institut National de la Recherche Scientifique) in Qu\u00e9bec, Canada, by Girard, Morin, and Charbonneau (1972). The name comes from the former name of the institute. In its original form, CEQUEAU is a spatially distributed model designed for use with physiographic databases, but it can also operate in lumped mode.</p> <p>The version implemented in HOLMES follows the simplified \"CEQU\" variant described in Perrin (2000), which reduces the original 11-parameter formulation to 9 parameters. This simplified version removes the impervious surface partitioning mechanism, fixes the evapotranspiration threshold, and adds a pure time delay parameter. Despite these simplifications, the core two-reservoir structure of the original model is preserved.</p> <p>CEQUEAU represents the catchment using two interconnected reservoirs: a surface (soil) store that handles precipitation, evapotranspiration, and infiltration, and a groundwater store that receives percolated water and produces slower flow components. Both reservoirs generate multiple outflow pathways \u2014 some threshold-based, some continuous \u2014 giving the model considerable flexibility in reproducing different hydrograph shapes.</p>"},{"location":"concepts/cequeau/#key-concepts","title":"Key Concepts","text":"<ul> <li> <p>Surface store: The upper reservoir receiving precipitation directly. It produces three distinct outflow pathways (overflow, threshold-based drainage, and continuous drainage) and loses water to both evapotranspiration and infiltration to the groundwater store.</p> </li> <li> <p>Groundwater store: The lower reservoir fed by infiltration from the surface store. It produces two outflow pathways (threshold-based hypodermic flow and continuous baseflow) and is also subject to evapotranspiration from remaining PET demand.</p> </li> <li> <p>Threshold-based drainage: Several outflows in CEQUEAU activate only when the store level exceeds a threshold. This allows the model to represent nonlinear behavior where certain flow pathways only contribute during wet conditions.</p> </li> <li> <p>Continuous drainage: Other outflows are proportional to the current store level regardless of any threshold, providing a baseline contribution at all times.</p> </li> <li> <p>Routing delay: A pure time translation applied to the total streamflow before output, representing the travel time of water through the channel network to the catchment outlet.</p> </li> </ul>"},{"location":"concepts/cequeau/#how-it-works","title":"How It Works","text":"<p>CEQUEAU operates on a daily time step, processing precipitation and potential evapotranspiration through the following sequence:</p> <p>Step 1: Precipitation input. All precipitation enters the surface store directly. Unlike the original CEQUEAU model, the simplified version does not partition precipitation between impervious surface runoff and soil input (the TRI coefficient is set to zero).</p> <p>Step 2: Surface evapotranspiration. The surface store loses water to evapotranspiration. Actual evapotranspiration is limited by both the PET demand and the available water, with a linear scaling factor that depends on the ratio of the store level to half its capacity (\\(X_5/2\\)). When the store is more than half full, actual ET equals potential ET; below that, it decreases linearly.</p> <p>Step 3: Infiltration (percolation). Water above the infiltration threshold \\(X_1\\) percolates to the groundwater store at a rate controlled by the infiltration constant \\(X_3\\). This is the only pathway connecting the two reservoirs.</p> <p>Step 4: Surface drainage. The surface store produces three outflows in sequence: threshold-based lateral drainage (above \\(X_2\\), controlled by \\(X_4\\)), continuous lateral drainage (controlled by \\(X_4 \\cdot X_8\\)), and overflow if the store exceeds its capacity \\(X_5\\). Each outflow is subtracted from the store before the next is computed, so their order matters.</p> <p>Step 5: Groundwater dynamics. The groundwater store receives the infiltrated water and produces two outflows: threshold-based hypodermic flow (above \\(X_7\\), controlled by \\(X_4 \\cdot X_9\\)) and continuous baseflow (controlled by \\(X_4 \\cdot X_8 \\cdot X_9^2\\)). Any remaining PET demand after surface evapotranspiration is applied to the groundwater store, again with linear scaling relative to \\(X_7\\).</p> <p>Step 6: Total streamflow and delay. The five outflow components are summed to produce total streamflow, which is then delayed by \\(X_6\\) time steps using linear interpolation for non-integer delays.</p>"},{"location":"concepts/cequeau/#parameters","title":"Parameters","text":"<p>CEQUEAU (CEQU variant) has nine calibratable parameters:</p> Parameter Description Range Units Physical Interpretation \\(X_1\\) Infiltration threshold 0\u20133000 mm Surface store level above which water infiltrates to the groundwater store. Higher values reduce percolation. \\(X_2\\) Soil drainage threshold 1\u20133000 mm Surface store level above which threshold-based lateral drainage occurs. Controls when quick lateral flow activates. \\(X_3\\) Infiltration constant 1\u2013100 - Controls the rate of infiltration. Larger values slow infiltration to the groundwater store. \\(X_4\\) Upper drainage constant 1\u201350 - Primary drainage time constant for the surface store. Also appears as a factor in groundwater drainage constants. \\(X_5\\) Surface store capacity 1\u20138000 mm Maximum capacity of the surface (soil) reservoir. Also determines the evapotranspiration scaling threshold at \\(X_5/2\\). \\(X_6\\) Routing delay 0.1\u201320 days Pure time translation applied to total streamflow. Reflects channel travel time to the outlet. \\(X_7\\) Groundwater drainage threshold 0.01\u2013500 mm Groundwater store level above which hypodermic flow occurs. Also scales groundwater evapotranspiration. \\(X_8\\) Lower drainage constant 1\u20131000 - Multiplier for continuous (slow) drainage from the surface store. Also contributes to groundwater baseflow constant. \\(X_9\\) Groundwater drainage constant 1\u20133000 - Controls both hypodermic flow rate (as \\(X_4 \\cdot X_9\\)) and baseflow rate (as \\(X_4 \\cdot X_8 \\cdot X_9^2\\)). <p>Understanding the parameters:</p> <ul> <li>\\(X_1\\) and \\(X_2\\) are thresholds that control when different drainage pathways activate. If \\(X_1\\) is very large, almost no water reaches the groundwater store; if \\(X_2\\) is very large, the threshold-based surface drainage rarely activates.</li> <li>\\(X_3\\) and \\(X_4\\) are the primary drainage constants. \\(X_4\\) appears in multiple outflow equations, making it a central parameter that influences the overall speed of the catchment response.</li> <li>\\(X_5\\) plays a dual role: it sets the overflow threshold for the surface store and determines when evapotranspiration becomes water-limited (at \\(X_5/2\\)).</li> <li>\\(X_6\\) is purely a timing parameter \u2014 it shifts the entire hydrograph without changing its shape.</li> <li>\\(X_8\\) and \\(X_9\\) interact with \\(X_4\\) to form composite drainage constants for the slower flow pathways. This parameterization means that adjusting \\(X_4\\) affects all drainage rates simultaneously.</li> </ul>"},{"location":"concepts/cequeau/#mathematical-formulation","title":"Mathematical Formulation","text":""},{"location":"concepts/cequeau/#initialization","title":"Initialization","text":"<p>The surface store is initialized at a fixed level, while the groundwater store is set to 20% of its capacity parameter:</p> \\[S_0 = 500, \\quad T_0 = 0.2 \\cdot X_5\\] <p>where \\(S\\) is the surface store level and \\(T\\) is the groundwater store level.</p>"},{"location":"concepts/cequeau/#surface-store-precipitation-and-evapotranspiration","title":"Surface Store: Precipitation and Evapotranspiration","text":"<p>Precipitation is added directly to the surface store:</p> \\[S \\leftarrow S + P\\] <p>Actual evapotranspiration from the surface store is limited by both the PET demand and available water, with linear scaling when the store is below half capacity:</p> \\[E_s = \\min\\!\\left(S,\\ E \\cdot \\min\\!\\left(1,\\ \\frac{2S}{X_5}\\right)\\right)\\] <p>The store is updated and the remaining PET demand is computed:</p> \\[S \\leftarrow S - E_s, \\quad E' = E - E_s\\]"},{"location":"concepts/cequeau/#surface-store-infiltration","title":"Surface Store: Infiltration","text":"<p>Water above the infiltration threshold percolates to the groundwater store:</p> \\[I_s = \\frac{\\max(0,\\ S - X_1)}{X_3}\\] \\[S \\leftarrow S - I_s\\]"},{"location":"concepts/cequeau/#surface-store-drainage","title":"Surface Store: Drainage","text":"<p>Three outflows are computed sequentially, each depleting the store before the next:</p> <p>Threshold-based lateral drainage (activated when \\(S &gt; X_2\\)):</p> \\[Q_{s2} = \\frac{\\max(0,\\ S - X_2)}{X_4}\\] \\[S \\leftarrow S - Q_{s2}\\] <p>Continuous lateral drainage (always active):</p> \\[Q_{s3} = \\frac{S}{X_4 \\cdot X_8}\\] \\[S \\leftarrow S - Q_{s3}\\] <p>Overflow (when the store exceeds capacity):</p> \\[Q_{s1} = \\max(0,\\ S - X_5)\\] \\[S \\leftarrow S - Q_{s1}\\]"},{"location":"concepts/cequeau/#groundwater-store","title":"Groundwater Store","text":"<p>The groundwater store receives infiltration from the surface store:</p> \\[T \\leftarrow T + I_s\\] <p>Threshold-based hypodermic flow (activated when \\(T &gt; X_7\\)):</p> \\[Q_{t1} = \\frac{\\max(0,\\ T - X_7)}{X_4 \\cdot X_9}\\] \\[T \\leftarrow T - Q_{t1}\\] <p>Continuous baseflow:</p> \\[Q_{t2} = \\frac{T}{X_4 \\cdot X_8 \\cdot X_9^2}\\] \\[T \\leftarrow T - Q_{t2}\\] <p>Groundwater evapotranspiration from the remaining PET demand:</p> \\[E_t = \\min\\!\\left(T,\\ E' \\cdot \\min\\!\\left(1,\\ \\frac{T}{X_7}\\right)\\right)\\] \\[T \\leftarrow T - E_t\\]"},{"location":"concepts/cequeau/#total-streamflow","title":"Total Streamflow","text":"<p>The total streamflow is the sum of all five drainage components:</p> \\[Q_{total} = Q_{s1} + Q_{s2} + Q_{s3} + Q_{t1} + Q_{t2}\\]"},{"location":"concepts/cequeau/#routing-delay","title":"Routing Delay","text":"<p>The total streamflow is delayed by \\(X_6\\) time steps using a linear interpolation scheme. For a delay of \\(X_6\\) days, a delay line of length \\(\\lceil X_6 \\rceil + 1\\) distributes the flow between two adjacent positions to handle non-integer delays:</p> \\[Q(t) = \\text{delayed}(Q_{total},\\ X_6)\\]"},{"location":"concepts/cequeau/#differences-from-the-original-cequeau","title":"Differences from the Original CEQUEAU","text":"<p>The CEQU variant implemented in HOLMES differs from the original CEQUEAU model (Girard et al., 1972) in three ways:</p> <ol> <li> <p>No impervious surface partitioning: The TRI coefficient and HRIMP threshold are removed. All precipitation enters the surface store directly, reducing the parameter count by two.</p> </li> <li> <p>Fixed evapotranspiration threshold: The original model uses a separate parameter (HINT) as the threshold above which actual ET equals potential ET. The simplified version fixes this threshold at half the surface store capacity (\\(X_5/2\\)), eliminating one parameter.</p> </li> <li> <p>Added routing delay: A pure time delay parameter (\\(X_6\\)) is added to translate the total streamflow in time, representing channel routing. The original model handles routing through its distributed grid structure.</p> </li> </ol>"},{"location":"concepts/cequeau/#references","title":"References","text":"<p>Girard, G., Morin, G., &amp; Charbonneau, R. (1972). Mod\u00e8le pr\u00e9cipitations-d\u00e9bits \u00e0 discr\u00e9tisation spatiale. Cahiers ORSTOM, S\u00e9rie Hydrologie, IX(4), 35-52.</p> <p>Perrin, C. (2000). Vers une am\u00e9lioration d'un mod\u00e8le global pluie-d\u00e9bit. PhD Thesis, INPG Grenoble, Appendix 1, pp. 322-326. https://tel.archives-ouvertes.fr/tel-00006216</p>"},{"location":"concepts/gr4j/","title":"GR4J Model","text":""},{"location":"concepts/gr4j/#overview","title":"Overview","text":"<p>GR4J (G\u00e9nie Rural \u00e0 4 param\u00e8tres Journalier) is a daily lumped rainfall-runoff model developed by IRSTEA (formerly Cemagref) in France. The name translates to \"Rural Engineering with 4 Daily Parameters,\" reflecting both its origins in French agricultural water management and its parsimonious design.</p> <p>GR4J has become one of the most widely used conceptual hydrological models worldwide, appearing in hundreds of research publications and operational forecasting systems. Its popularity stems from a careful balance: it is simple enough to calibrate reliably with limited data, yet complex enough to capture the essential dynamics of catchment hydrology. With only four parameters, GR4J avoids the overparameterization problems that plague more complex models while still achieving strong predictive performance across diverse climatic and physiographic conditions.</p> <p>The model represents a catchment as two interconnected reservoirs: a production store that handles soil moisture accounting and a routing store that controls baseflow generation. Water moves through the system via two parallel pathways with different response times, allowing the model to reproduce both the quick response to rainfall events and the slower baseflow recession.</p>"},{"location":"concepts/gr4j/#key-concepts","title":"Key Concepts","text":"<ul> <li> <p>Lumped model: Treats the entire catchment as a single unit without spatial discretization. All processes are averaged over the catchment area.</p> </li> <li> <p>Conceptual approach: Uses reservoirs and transfer functions to represent physical processes rather than solving the underlying physics directly. This trades some physical realism for practical applicability.</p> </li> <li> <p>Production store: The upper reservoir that partitions incoming water between storage, evaporation, and percolation. Think of it as representing the soil's capacity to absorb and hold water.</p> </li> <li> <p>Routing store: The lower reservoir that generates baseflow and receives water from the production store. Represents the slower groundwater component of streamflow.</p> </li> <li> <p>Unit hydrographs: Mathematical functions that distribute flow in time, representing the delay between water entering the system and appearing at the outlet. GR4J uses two unit hydrographs with different lengths.</p> </li> <li> <p>Groundwater exchange: A term allowing water to enter or leave the modeled system, representing interactions with deep aquifers or neighboring catchments that cannot be directly measured.</p> </li> </ul>"},{"location":"concepts/gr4j/#how-it-works","title":"How It Works","text":"<p>GR4J operates on a daily time step, processing precipitation and potential evapotranspiration to produce streamflow. The model structure can be understood as a series of water transformations:</p> <p>Step 1: Net inputs. The model first determines whether the day is wet (precipitation exceeds PET) or dry (PET exceeds precipitation). This determines whether water enters or leaves the production store.</p> <p>Step 2: Production store dynamics. During wet periods, precipitation fills the production store following a saturation curve\u2014a nearly empty store accepts water readily, while a nearly full store accepts little. During dry periods, evaporation depletes the store following a similar nonlinear relationship. Water that cannot enter the store becomes available for routing.</p> <p>Step 3: Percolation. A fraction of water in the production store percolates downward regardless of conditions. This percolation increases nonlinearly as the store fills, representing gravity-driven drainage.</p> <p>Step 4: Flow partitioning. Water available for routing (surface excess plus percolation) splits between two pathways: 90% follows a slower route through the routing store, while 10% takes a faster direct path.</p> <p>Step 5: Unit hydrograph convolution. Each pathway's water is delayed by a unit hydrograph that spreads the response over multiple days. The slow pathway uses a longer hydrograph (up to \\(X_4\\) days), while the fast pathway uses a shorter one (up to \\(2X_4\\) days, but quicker peak).</p> <p>Step 6: Routing store and exchange. Water from the slow pathway enters the routing store, which generates outflow following a power-law relationship. Simultaneously, groundwater exchange adds or removes water from the system.</p> <p>Step 7: Total streamflow. The model sums outflow from the routing store and the direct pathway to produce total streamflow.</p>"},{"location":"concepts/gr4j/#parameters","title":"Parameters","text":"<p>GR4J has exactly four parameters that must be calibrated:</p> Parameter Description Range Units Physical Interpretation \\(X_1\\) Production store capacity 10\u20131500 mm Maximum soil water storage. Larger values indicate greater soil depth or water-holding capacity. \\(X_2\\) Groundwater exchange coefficient -5 to 3 mm/day Water exchange with deep aquifers. Negative values indicate losses; positive indicates gains. \\(X_3\\) Routing store capacity 10\u2013400 mm Size of the baseflow reservoir. Controls the volume of slow-release storage. \\(X_4\\) Unit hydrograph time base 0.8\u201310 days Characteristic response time. Controls how quickly the catchment responds to rainfall. <p>Practical guidance on parameters:</p> <ul> <li>\\(X_1\\) typically ranges from 100\u2013500 mm for most catchments. Very large values (&gt;1000 mm) may indicate model identifiability problems.</li> <li>\\(X_2\\) is often negative (water loss to deep aquifers is common). Values near zero suggest a closed water balance.</li> <li>\\(X_3\\) interacts with \\(X_4\\) in controlling recession behavior. Larger \\(X_3\\) produces more sustained baseflow.</li> <li>\\(X_4\\) reflects catchment size and slope. Smaller, steeper catchments have lower \\(X_4\\); larger, flatter catchments have higher values.</li> </ul>"},{"location":"concepts/gr4j/#mathematical-formulation","title":"Mathematical Formulation","text":""},{"location":"concepts/gr4j/#initialization","title":"Initialization","text":"<p>The stores are initialized at half capacity:</p> \\[S_0 = \\frac{X_1}{2}, \\quad R_0 = \\frac{X_3}{2}\\] <p>where \\(S\\) is the production store level and \\(R\\) is the routing store level.</p>"},{"location":"concepts/gr4j/#net-precipitation-and-evapotranspiration","title":"Net Precipitation and Evapotranspiration","text":"<p>Given precipitation \\(P\\) and potential evapotranspiration \\(E\\):</p> \\[P_n = \\max(P - E, 0)\\] \\[E_n = \\max(E - P, 0)\\] <p>where \\(P_n\\) is net precipitation (when \\(P &gt; E\\)) and \\(E_n\\) is net evapotranspiration (when \\(E &gt; P\\)).</p>"},{"location":"concepts/gr4j/#production-store","title":"Production Store","text":"<p>Filling (wet conditions, \\(P_n &gt; 0\\)):</p> <p>The fraction of net precipitation entering the store follows a saturation function:</p> \\[P_s = \\frac{X_1 \\left(1 - \\left(\\frac{S}{X_1}\\right)^2\\right) \\tanh\\left(\\frac{P_n}{X_1}\\right)}{1 + \\frac{S}{X_1} \\tanh\\left(\\frac{P_n}{X_1}\\right)}\\] <p>The store is then updated: \\(S \\leftarrow S + P_s\\)</p> <p>Emptying (dry conditions, \\(E_n &gt; 0\\)):</p> <p>Actual evaporation from the store:</p> \\[E_s = \\frac{S \\left(2 - \\frac{S}{X_1}\\right) \\tanh\\left(\\frac{E_n}{X_1}\\right)}{1 + \\left(1 - \\frac{S}{X_1}\\right) \\tanh\\left(\\frac{E_n}{X_1}\\right)}\\] <p>The store is then updated: \\(S \\leftarrow S - E_s\\)</p> <p>Percolation:</p> <p>Water percolates from the production store regardless of wet/dry conditions:</p> \\[\\text{Perc} = S \\left(1 - \\left(1 + \\left(\\frac{4S}{9X_1}\\right)^4\\right)^{-0.25}\\right)\\] <p>The store is updated: \\(S \\leftarrow S - \\text{Perc}\\)</p> <p>Routing precipitation:</p> <p>Water available for routing combines surface excess and percolation:</p> \\[P_r = P_n - P_s + \\text{Perc}\\] <p>(In dry conditions, \\(P_n = P_s = 0\\), so \\(P_r = \\text{Perc}\\))</p>"},{"location":"concepts/gr4j/#unit-hydrographs","title":"Unit Hydrographs","text":"<p>GR4J uses two unit hydrographs to distribute flow in time. Both are based on S-curves (cumulative distributions):</p> <p>UH1 (for 90% of flow, slower pathway):</p> \\[SH_1(t) = \\begin{cases} 0 &amp; t = 0 \\\\ \\left(\\frac{t}{X_4}\\right)^{2.5} &amp; 0 &lt; t &lt; X_4 \\\\ 1 &amp; t \\geq X_4 \\end{cases}\\] <p>UH2 (for 10% of flow, faster pathway):</p> \\[SH_2(t) = \\begin{cases} 0 &amp; t = 0 \\\\ \\frac{1}{2}\\left(\\frac{t}{X_4}\\right)^{2.5} &amp; 0 &lt; t &lt; X_4 \\\\ 1 - \\frac{1}{2}\\left(2 - \\frac{t}{X_4}\\right)^{2.5} &amp; X_4 \\leq t &lt; 2X_4 \\\\ 1 &amp; t \\geq 2X_4 \\end{cases}\\] <p>The unit hydrograph ordinates are computed as:</p> \\[UH_1(j) = SH_1(j) - SH_1(j-1), \\quad j = 1, 2, \\ldots, \\lceil X_4 \\rceil\\] \\[UH_2(j) = SH_2(j) - SH_2(j-1), \\quad j = 1, 2, \\ldots, \\lceil 2X_4 \\rceil\\] <p>The routed flows are computed by convolution:</p> \\[Q_9(t) = 0.9 \\sum_{j=1}^{\\lceil X_4 \\rceil} UH_1(j) \\cdot P_r(t-j+1)\\] \\[Q_1(t) = 0.1 \\sum_{j=1}^{\\lceil 2X_4 \\rceil} UH_2(j) \\cdot P_r(t-j+1)\\]"},{"location":"concepts/gr4j/#groundwater-exchange","title":"Groundwater Exchange","text":"<p>The exchange term depends on the routing store level:</p> \\[F = X_2 \\left(\\frac{R}{X_3}\\right)^{3.5}\\] <p>A positive \\(X_2\\) adds water to the system; negative \\(X_2\\) removes water.</p>"},{"location":"concepts/gr4j/#routing-store","title":"Routing Store","text":"<p>The routing store receives water from UH1 and exchanges with groundwater:</p> \\[R \\leftarrow \\max(R + Q_9 + F, 0)\\] <p>Outflow from the routing store follows a power relationship:</p> \\[Q_r = R \\left(1 - \\left(1 + \\left(\\frac{R}{X_3}\\right)^4\\right)^{-0.25}\\right)\\] <p>The store is then depleted: \\(R \\leftarrow R - Q_r\\)</p>"},{"location":"concepts/gr4j/#direct-flow","title":"Direct Flow","text":"<p>The direct pathway also receives the groundwater exchange:</p> \\[Q_d = \\max(Q_1 + F, 0)\\]"},{"location":"concepts/gr4j/#total-streamflow","title":"Total Streamflow","text":"\\[Q = Q_r + Q_d\\]"},{"location":"concepts/gr4j/#references","title":"References","text":"<p>Perrin, C., Michel, C., &amp; Andr\u00e9assian, V. (2003). Improvement of a parsimonious model for streamflow simulation. Journal of Hydrology, 279(1-4), 275-289. https://doi.org/10.1016/S0022-1694(03)00225-7</p>"},{"location":"concepts/metrics/","title":"Performance Metrics","text":""},{"location":"concepts/metrics/#overview","title":"Overview","text":"<p>After calibrating a hydrological model, we need to assess how well it performs. Performance metrics quantify the agreement between simulated and observed streamflow, providing objective measures of model quality.</p> <p>No single metric captures all aspects of model performance. Peak flows, low flows, timing, volume, and variability each tell part of the story. Using multiple metrics provides a more complete picture of model strengths and weaknesses.</p> <p>HOLMES implements three widely-used metrics: RMSE (Root Mean Square Error), NSE (Nash-Sutcliffe Efficiency), and KGE (Kling-Gupta Efficiency). Each emphasizes different aspects of performance and is appropriate for different applications.</p>"},{"location":"concepts/metrics/#notation","title":"Notation","text":"<p>Throughout this page:</p> <ul> <li>\\(O_i\\) = observed streamflow at time step \\(i\\)</li> <li>\\(S_i\\) = simulated streamflow at time step \\(i\\)</li> <li>\\(\\bar{O}\\) = mean of observed streamflow</li> <li>\\(\\bar{S}\\) = mean of simulated streamflow</li> <li>\\(\\sigma_O\\) = standard deviation of observations</li> <li>\\(\\sigma_S\\) = standard deviation of simulations</li> <li>\\(n\\) = number of time steps</li> </ul>"},{"location":"concepts/metrics/#rmse-root-mean-square-error","title":"RMSE: Root Mean Square Error","text":""},{"location":"concepts/metrics/#definition","title":"Definition","text":"\\[RMSE = \\sqrt{\\frac{1}{n}\\sum_{i=1}^{n}(O_i - S_i)^2}\\]"},{"location":"concepts/metrics/#interpretation","title":"Interpretation","text":"<p>RMSE measures the average magnitude of errors between simulated and observed values. It has the same units as the data (e.g., mm/day or m\u00b3/s), making it directly interpretable as \"typical error size.\"</p> <p>Key properties:</p> <ul> <li>Range: \\([0, \\infty)\\)</li> <li>Perfect score: 0 (no errors)</li> <li>Units: Same as input data</li> <li>Squaring: Large errors contribute disproportionately (a 10 mm/day error counts 100 times more than a 1 mm/day error)</li> </ul>"},{"location":"concepts/metrics/#when-to-use-rmse","title":"When to Use RMSE","text":"<ul> <li>When you need error magnitude in physical units</li> <li>When large errors are particularly problematic</li> <li>For comparing models applied to the same catchment (not for cross-catchment comparison, as RMSE scales with flow magnitude)</li> </ul>"},{"location":"concepts/metrics/#limitations","title":"Limitations","text":"<ul> <li>Scale-dependent: A large catchment with high flows will naturally have higher RMSE than a small catchment, even if both models perform equally well relatively</li> <li>Sensitive to outliers: A few large errors can dominate the metric</li> <li>No skill reference: RMSE doesn't tell you whether the model is better than a simple baseline</li> </ul>"},{"location":"concepts/metrics/#example-interpretation","title":"Example Interpretation","text":"<p>If RMSE = 2.5 mm/day for a catchment with mean flow of 5 mm/day, the typical error is about 50% of mean flow\u2014indicating moderate performance. For a catchment with mean flow of 25 mm/day, the same RMSE would indicate excellent performance (10% error).</p>"},{"location":"concepts/metrics/#nse-nash-sutcliffe-efficiency","title":"NSE: Nash-Sutcliffe Efficiency","text":""},{"location":"concepts/metrics/#definition_1","title":"Definition","text":"\\[NSE = 1 - \\frac{\\sum_{i=1}^{n}(O_i - S_i)^2}{\\sum_{i=1}^{n}(O_i - \\bar{O})^2}\\]"},{"location":"concepts/metrics/#interpretation_1","title":"Interpretation","text":"<p>NSE compares model errors to the variance of observations. It answers: \"Is the model better than simply using the observed mean as a predictor?\"</p> <p>Key properties:</p> <ul> <li>Range: \\((-\\infty, 1]\\)</li> <li>Perfect score: 1 (simulations exactly match observations)</li> <li>Benchmark score: 0 (model is as good as using the mean)</li> <li>Negative values: Model is worse than the mean</li> <li>Dimensionless: Can compare across catchments</li> </ul>"},{"location":"concepts/metrics/#decomposition","title":"Decomposition","text":"<p>NSE can be understood as:</p> \\[NSE = 1 - \\frac{MSE}{Var(O)}\\] <p>where MSE is the mean squared error and Var(O) is the variance of observations. The model must explain more variance than it introduces as error to achieve positive NSE.</p>"},{"location":"concepts/metrics/#rating-guidelines","title":"Rating Guidelines","text":"NSE Interpretation &gt; 0.75 Very good 0.65 \u2013 0.75 Good 0.50 \u2013 0.65 Satisfactory 0.40 \u2013 0.50 Acceptable for some purposes &lt; 0.40 Unsatisfactory <p>These thresholds are guidelines, not strict rules. Acceptable performance depends on the application.</p>"},{"location":"concepts/metrics/#when-to-use-nse","title":"When to Use NSE","text":"<ul> <li>For general performance assessment</li> <li>When comparing models across different catchments</li> <li>For research publications (NSE is the most commonly reported metric)</li> </ul>"},{"location":"concepts/metrics/#limitations_1","title":"Limitations","text":"<ul> <li>Emphasis on high flows: Because errors are squared, NSE is dominated by performance during peak flows. A model that captures peaks well but misses low flows may still have high NSE.</li> <li>Sensitive to timing: A simulation that is correct in magnitude but shifted in time will have poor NSE.</li> <li>Mean benchmark: Using the mean as a benchmark may be too easy in catchments with high autocorrelation.</li> </ul>"},{"location":"concepts/metrics/#kge-kling-gupta-efficiency","title":"KGE: Kling-Gupta Efficiency","text":""},{"location":"concepts/metrics/#definition_2","title":"Definition","text":"\\[KGE = 1 - \\sqrt{(r-1)^2 + (\\alpha-1)^2 + (\\beta-1)^2}\\] <p>where:</p> <ul> <li>\\(r\\) = Pearson correlation coefficient between \\(O\\) and \\(S\\)</li> <li>\\(\\alpha = \\frac{\\sigma_S}{\\sigma_O}\\) = ratio of standard deviations (variability ratio)</li> <li>\\(\\beta = \\frac{\\bar{S}}{\\bar{O}}\\) = ratio of means (bias ratio)</li> </ul>"},{"location":"concepts/metrics/#component-interpretation","title":"Component Interpretation","text":"<p>KGE decomposes performance into three independent aspects:</p> Component Symbol Optimal Value Meaning Correlation \\(r\\) 1 Timing and shape Variability ratio \\(\\alpha\\) 1 Amplitude of variations Bias ratio \\(\\beta\\) 1 Mean water balance <p>Correlation (\\(r\\)): Measures how well the timing and pattern of simulated flows match observations. High correlation means peaks and troughs occur at the right times, even if magnitudes differ.</p> <p>Variability ratio (\\(\\alpha\\)): Compares the \"spread\" of simulations to observations. \\(\\alpha &gt; 1\\) means simulations are too variable; \\(\\alpha &lt; 1\\) means simulations are too damped.</p> <p>Bias ratio (\\(\\beta\\)): Compares mean flows. \\(\\beta &gt; 1\\) means the model overestimates on average; \\(\\beta &lt; 1\\) means underestimation.</p>"},{"location":"concepts/metrics/#expanded-form","title":"Expanded Form","text":"<p>The components are calculated as:</p> \\[r = \\frac{\\sum_{i=1}^{n}(O_i - \\bar{O})(S_i - \\bar{S})}{\\sqrt{\\sum_{i=1}^{n}(O_i - \\bar{O})^2} \\cdot \\sqrt{\\sum_{i=1}^{n}(S_i - \\bar{S})^2}}\\] \\[\\alpha = \\frac{\\sigma_S}{\\sigma_O} = \\frac{\\sqrt{\\frac{1}{n}\\sum_{i=1}^{n}(S_i - \\bar{S})^2}}{\\sqrt{\\frac{1}{n}\\sum_{i=1}^{n}(O_i - \\bar{O})^2}}\\] \\[\\beta = \\frac{\\bar{S}}{\\bar{O}}\\]"},{"location":"concepts/metrics/#key-properties","title":"Key Properties","text":"<ul> <li>Range: \\((-\\infty, 1]\\)</li> <li>Perfect score: 1 (all components equal 1)</li> <li>Benchmark: KGE = -0.41 corresponds to using the observed mean (like NSE = 0)</li> <li>Dimensionless: Can compare across catchments</li> <li>Diagnostic: Components reveal which aspects need improvement</li> </ul>"},{"location":"concepts/metrics/#rating-guidelines_1","title":"Rating Guidelines","text":"KGE Interpretation &gt; 0.75 Very good 0.50 \u2013 0.75 Good 0.00 \u2013 0.50 Acceptable &lt; 0.00 Poor"},{"location":"concepts/metrics/#when-to-use-kge","title":"When to Use KGE","text":"<ul> <li>When you want diagnostic information about model errors</li> <li>When water balance (bias) matters for your application</li> <li>When you want a more balanced assessment than NSE provides</li> <li>For operational hydrology where total volumes matter</li> </ul>"},{"location":"concepts/metrics/#advantages-over-nse","title":"Advantages Over NSE","text":"<ol> <li> <p>Balanced assessment: NSE can be high even with significant bias if variability is captured. KGE explicitly penalizes bias.</p> </li> <li> <p>Diagnostic value: The components tell you what to fix. Poor \\(r\\)? Work on timing. Poor \\(\\beta\\)? Adjust the water balance.</p> </li> <li> <p>More intuitive benchmark: NSE = 0 corresponds to using the mean, but KGE = 0 is a more meaningful threshold in practice.</p> </li> </ol>"},{"location":"concepts/metrics/#comparison-of-metrics","title":"Comparison of Metrics","text":"Aspect RMSE NSE KGE Units Same as data Dimensionless Dimensionless Range \\([0, \\infty)\\) \\((-\\infty, 1]\\) \\((-\\infty, 1]\\) Perfect 0 1 1 Cross-catchment comparison No Yes Yes Emphasis All errors equally (squared) High flows Balanced Diagnostic No Limited Yes (3 components) Bias sensitivity Implicit Low High Most common use Error magnitude Research Operational"},{"location":"concepts/metrics/#choosing-a-metric","title":"Choosing a Metric","text":"<p>The choice of metric should align with your modeling objectives:</p> <p>For flood forecasting: NSE or RMSE, as peak flow accuracy matters most.</p> <p>For water resources planning: KGE, because water balance (total volumes) is critical.</p> <p>For low flow assessment: Consider transforming flows (log or square root) before computing metrics, or use specific low-flow metrics.</p> <p>For research and publication: Report multiple metrics. NSE for comparability with literature; KGE for diagnostic insight; RMSE for physical interpretation.</p> <p>Best practice: Always report at least two metrics. High NSE with poor KGE components (e.g., biased mean) reveals important model limitations.</p>"},{"location":"concepts/metrics/#practical-tips","title":"Practical Tips","text":"<ol> <li> <p>Examine time series plots in addition to metrics. A metric is a summary; the plot shows details.</p> </li> <li> <p>Calculate metrics for subperiods: Calibration vs. validation, wet vs. dry years, different seasons. Performance may vary.</p> </li> <li> <p>Consider flow transformation: Log transformation emphasizes low flows; square root provides intermediate emphasis.</p> </li> <li> <p>Watch for suspect values: A single missing observation coded as -999 can ruin all metrics. Check data quality first.</p> </li> <li> <p>Report uncertainty: If you run multiple calibrations, report the range of metrics, not just the best run.</p> </li> </ol>"},{"location":"concepts/metrics/#references","title":"References","text":"<p>Nash, J. E., &amp; Sutcliffe, J. V. (1970). River flow forecasting through conceptual models part I\u2014A discussion of principles. Journal of Hydrology, 10(3), 282-290. https://doi.org/10.1016/0022-1694(70)90255-6</p> <p>The seminal paper introducing NSE, one of the most cited papers in hydrology. Establishes the concept of comparing model errors to observation variance.</p> <p>Gupta, H. V., Kling, H., Yilmaz, K. K., &amp; Martinez, G. F. (2009). Decomposition of the mean squared error and NSE performance criteria: Implications for improving hydrological modelling. Journal of Hydrology, 377(1-2), 80-91. https://doi.org/10.1016/j.jhydrol.2009.08.003</p> <p>Introduces KGE and demonstrates its advantages over NSE. Shows how NSE can mask important model deficiencies.</p> <p>Moriasi, D. N., Arnold, J. G., Van Liew, M. W., Bingner, R. L., Harmel, R. D., &amp; Veith, T. L. (2007). Model evaluation guidelines for systematic quantification of accuracy in watershed simulations. Transactions of the ASABE, 50(3), 885-900.</p> <p>Provides widely-cited guidelines for acceptable performance levels (NSE &gt; 0.5 for satisfactory performance).</p>"},{"location":"concepts/pet-models/","title":"Potential Evapotranspiration Models","text":""},{"location":"concepts/pet-models/#oudin-model","title":"Oudin Model","text":""},{"location":"concepts/pet-models/#overview","title":"Overview","text":"<p>Potential evapotranspiration (PET) represents the maximum amount of water that would evaporate from a well-watered surface given unlimited water supply. It quantifies the atmospheric demand for water\u2014how much the atmosphere \"wants\" to extract from the land surface based on available energy and vapor pressure deficit.</p> <p>PET is a critical input for rainfall-runoff models because it determines how much precipitation returns to the atmosphere versus how much becomes streamflow. Without accounting for evapotranspiration, a water balance model would systematically overestimate runoff.</p> <p>The Oudin method is a parsimonious approach to estimating PET that requires only temperature and latitude. Developed specifically for use with lumped rainfall-runoff models like GR4J, it trades physical complexity for practical applicability. While more sophisticated methods (like Penman-Monteith) require wind speed, humidity, and radiation measurements that are often unavailable, the Oudin method can be applied anywhere temperature records exist.</p>"},{"location":"concepts/pet-models/#key-concepts","title":"Key Concepts","text":"<ul> <li> <p>Evapotranspiration: The combined process of evaporation from surfaces (lakes, soil, wet vegetation) and transpiration from plants. Together, these processes return water to the atmosphere.</p> </li> <li> <p>Potential vs. actual evapotranspiration: PET assumes unlimited water availability. Actual evapotranspiration (AET) may be less than PET when water is limiting (dry soil, stressed plants). The hydrological model calculates AET based on soil moisture availability.</p> </li> <li> <p>Extraterrestrial radiation: Solar radiation at the top of the atmosphere before any absorption by clouds or the atmosphere. It depends only on latitude and day of year, making it predictable from astronomical calculations.</p> </li> <li> <p>Energy-temperature relationship: Temperature serves as a proxy for the energy available for evaporation. Warmer air typically indicates more incoming solar radiation and greater evaporative demand.</p> </li> </ul>"},{"location":"concepts/pet-models/#how-it-works","title":"How It Works","text":"<p>The Oudin method calculates PET in two steps:</p> <p>Step 1: Calculate extraterrestrial radiation. Using latitude and day of year, compute the solar radiation that would reach the catchment if there were no atmosphere. This captures the seasonal and latitudinal variation in available energy.</p> <p>Step 2: Convert to PET. Scale the extraterrestrial radiation by a temperature-dependent factor. Above a threshold temperature, higher temperatures produce more PET. Below the threshold, PET is zero (no evaporation demand).</p> <p>The method assumes that temperature captures the relevant energy balance information, avoiding the need for direct radiation measurements.</p>"},{"location":"concepts/pet-models/#mathematical-formulation","title":"Mathematical Formulation","text":""},{"location":"concepts/pet-models/#solar-geometry","title":"Solar Geometry","text":"<p>The calculation begins with astronomical relationships that determine how much solar energy reaches the top of the atmosphere.</p> <p>Solar declination (the angle between the Sun and the equatorial plane):</p> \\[\\delta = 0.409 \\sin\\left(\\frac{2\\pi \\cdot DOY}{365} - 1.39\\right)\\] <p>where \\(DOY\\) is the day of year (1\u2013365).</p> <p>Inverse relative Earth-Sun distance (accounts for Earth's elliptical orbit):</p> \\[d_r = 1 + 0.033 \\cos\\left(\\frac{2\\pi \\cdot DOY}{365}\\right)\\] <p>Sunset hour angle (determines day length):</p> \\[\\omega_s = \\arccos\\left(-\\tan(\\phi) \\cdot \\tan(\\delta)\\right)\\] <p>where \\(\\phi\\) is latitude in radians. The argument is clamped to \\([-1, 1]\\) to handle polar latitudes where the sun doesn't set (midnight sun) or doesn't rise (polar night).</p>"},{"location":"concepts/pet-models/#extraterrestrial-radiation","title":"Extraterrestrial Radiation","text":"<p>The daily extraterrestrial radiation (energy per unit area at the top of the atmosphere):</p> \\[R_e = \\frac{24 \\cdot 60}{\\pi} G_{sc} \\cdot d_r \\left[\\omega_s \\sin(\\phi) \\sin(\\delta) + \\cos(\\phi) \\cos(\\delta) \\sin(\\omega_s)\\right]\\] <p>where:</p> <ul> <li>\\(G_{sc} = 0.082\\) MJ m\u207b\u00b2 min\u207b\u00b9 is the solar constant</li> <li>Result is in MJ m\u207b\u00b2 day\u207b\u00b9</li> </ul>"},{"location":"concepts/pet-models/#latent-heat-of-vaporization","title":"Latent Heat of Vaporization","text":"<p>The energy required to evaporate water decreases slightly with temperature:</p> \\[\\lambda = 2.501 - 0.002361 \\cdot T\\] <p>where \\(\\lambda\\) is in MJ kg\u207b\u00b9 and \\(T\\) is temperature in \u00b0C.</p>"},{"location":"concepts/pet-models/#potential-evapotranspiration","title":"Potential Evapotranspiration","text":"<p>The Oudin formula for PET:</p> \\[PET = \\begin{cases} \\frac{R_e}{\\lambda \\cdot \\rho} \\cdot \\frac{T + 5}{100} \\cdot 1000 &amp; T &gt; -5\u00b0C \\\\ 0 &amp; T \\leq -5\u00b0C \\end{cases}\\] <p>where:</p> <ul> <li>\\(\\rho = 1000\\) kg m\u207b\u00b3 is water density</li> <li>Result is in mm day\u207b\u00b9</li> <li>The factor \\((T + 5)/100\\) is an empirical calibration term</li> </ul> <p>Understanding the formula:</p> <p>The expression \\(R_e / (\\lambda \\cdot \\rho)\\) converts radiation energy to equivalent water depth (how much water could be evaporated by that energy). The factor \\((T + 5)/100\\) scales this based on temperature, with the +5 offset ensuring PET remains positive even at slightly negative temperatures (when sublimation can still occur).</p>"},{"location":"concepts/pet-models/#constants-and-parameters","title":"Constants and Parameters","text":"<p>The Oudin method uses fixed constants\u2014there are no calibratable parameters:</p> Constant Value Units Description \\(G_{sc}\\) 0.082 MJ m\u207b\u00b2 min\u207b\u00b9 Solar constant \\(\\rho\\) 1000 kg m\u207b\u00b3 Water density \\(T_{offset}\\) 5 \u00b0C Empirical temperature offset \\(T_{threshold}\\) -5 \u00b0C Minimum temperature for PET <p>The only input parameter is latitude, which HOLMES obtains from the catchment data.</p>"},{"location":"concepts/pet-models/#practical-considerations","title":"Practical Considerations","text":""},{"location":"concepts/pet-models/#advantages-of-the-oudin-method","title":"Advantages of the Oudin Method","text":"<ol> <li> <p>Minimal data requirements: Only needs temperature and location (latitude). No wind, humidity, or radiation measurements required.</p> </li> <li> <p>Robust for rainfall-runoff modeling: Specifically designed and tested for use with lumped models like GR4J. The empirical calibration accounts for the fact that the hydrological model will further adjust actual evapotranspiration.</p> </li> <li> <p>Physically reasonable: Despite its simplicity, captures the main drivers of evaporative demand\u2014energy availability (radiation) and temperature.</p> </li> <li> <p>Consistent: No subjective choices about crop coefficients, albedo, or other parameters that can introduce uncertainty.</p> </li> </ol>"},{"location":"concepts/pet-models/#limitations","title":"Limitations","text":"<ol> <li> <p>No vegetation effects: Does not distinguish between forest, grassland, or bare soil. In reality, vegetation type affects evapotranspiration rates.</p> </li> <li> <p>No wind or humidity: Ignores atmospheric conditions that influence evaporation rate. May underperform in very windy or very humid conditions.</p> </li> <li> <p>Daily time step: The formulation assumes daily averaging. Not suitable for sub-daily calculations without modification.</p> </li> <li> <p>Empirical calibration: The \\((T + 5)/100\\) factor was calibrated against more complex PET methods and may not be optimal everywhere.</p> </li> </ol>"},{"location":"concepts/pet-models/#comparison-with-other-methods","title":"Comparison with Other Methods","text":"Method Data Requirements Complexity Best For Oudin Temperature, latitude Low Lumped rainfall-runoff models Hargreaves Temperature, latitude Low Arid regions Penman-Monteith Temperature, humidity, wind, radiation High Irrigation scheduling, detailed studies Priestley-Taylor Temperature, radiation Medium Energy-limited environments <p>For the purposes of educational rainfall-runoff modeling in HOLMES, the Oudin method provides an appropriate balance of simplicity and accuracy.</p>"},{"location":"concepts/pet-models/#typical-pet-values","title":"Typical PET Values","text":"<p>To help interpret model outputs, here are typical daily PET ranges:</p> Climate Summer Winter Tropical 4\u20136 mm/day 3\u20135 mm/day Mediterranean 6\u20138 mm/day 1\u20132 mm/day Temperate 3\u20135 mm/day 0.5\u20131.5 mm/day Continental 4\u20136 mm/day 0\u20131 mm/day Subarctic 2\u20134 mm/day 0 mm/day <p>If your calculated PET values fall outside these ranges, verify your input data (especially latitude and temperature units).</p>"},{"location":"concepts/pet-models/#references","title":"References","text":"<p>Oudin, L., Hervieu, F., Michel, C., Perrin, C., Andr\u00e9assian, V., Anctil, F., &amp; Loumagne, C. (2005). Which potential evapotranspiration input for a lumped rainfall\u2013runoff model?: Part 2\u2014Towards a simple and efficient potential evapotranspiration model for rainfall\u2013runoff modelling. Journal of Hydrology, 303(1-4), 290-306. https://doi.org/10.1016/j.jhydrol.2004.08.026</p> <p>This paper presents the Oudin method, comparing it against 27 other PET formulations across 308 catchments and showing that simple temperature-based methods work as well as complex ones for rainfall-runoff modeling.</p> <p>Allen, R. G., Pereira, L. S., Raes, D., &amp; Smith, M. (1998). Crop evapotranspiration: Guidelines for computing crop water requirements. FAO Irrigation and Drainage Paper 56. Food and Agriculture Organization of the United Nations.</p> <p>The definitive reference for the Penman-Monteith equation and evapotranspiration calculations. While more detailed than needed for HOLMES, it provides essential background on the physics of evapotranspiration.</p>"},{"location":"concepts/snow-models/","title":"Snow Models","text":""},{"location":"concepts/snow-models/#cemaneige-model","title":"CemaNeige Model","text":""},{"location":"concepts/snow-models/#overview","title":"Overview","text":"<p>In many catchments worldwide, snow plays a fundamental role in the hydrological cycle. Precipitation falls as snow during cold periods, accumulates in a snowpack, and releases water during spring melt\u2014fundamentally altering the timing and magnitude of streamflow compared to rain-fed catchments. Understanding and modeling these processes is essential for water resources management in mountain regions.</p> <p>CemaNeige is a degree-day snow accounting model developed alongside GR4J by researchers at IRSTEA (formerly Cemagref) in France. Like GR4J, CemaNeige emphasizes parsimony: it captures the essential dynamics of snow accumulation and melt with just three parameters, making it practical for catchments where detailed snow observations are unavailable.</p> <p>CemaNeige operates as a preprocessor to the hydrological model. It receives precipitation and temperature, tracks snowpack evolution across elevation bands, and outputs effective precipitation (rain plus snowmelt) that feeds into GR4J or the bucket model.</p>"},{"location":"concepts/snow-models/#key-concepts","title":"Key Concepts","text":"<ul> <li> <p>Degree-day method: A simple approach relating snowmelt to air temperature. Each degree above freezing produces a certain amount of melt. While physically simplistic, it works remarkably well in practice because temperature correlates with the energy balance components that drive melt.</p> </li> <li> <p>Snow water equivalent (SWE): The amount of water contained in the snowpack, measured as the depth of water that would result if the snow melted instantaneously. More meaningful than snow depth because it accounts for snow density.</p> </li> <li> <p>Thermal state: The internal \"temperature\" of the snowpack. A cold snowpack (negative thermal state) must warm up before melt can begin, creating a delay between warm temperatures and melt onset.</p> </li> <li> <p>Elevation bands: Mountain catchments span wide elevation ranges with very different temperatures. CemaNeige divides the catchment into elevation layers, each with its own temperature and snowpack, to better represent spatial variability.</p> </li> <li> <p>Rain-snow partitioning: The transition between rain and snow is not sharp\u2014near 0\u00b0C, precipitation can be a mixture. CemaNeige uses a linear transition over a 4\u00b0C temperature range.</p> </li> </ul>"},{"location":"concepts/snow-models/#how-it-works","title":"How It Works","text":"<p>CemaNeige processes precipitation through a sequence of steps for each elevation band:</p> <p>Step 1: Temperature adjustment. The measured temperature (usually from a valley station) is adjusted for each elevation band using a temperature lapse rate that varies by day of year.</p> <p>Step 2: Rain-snow partitioning. Precipitation divides between rain (passes through immediately) and snow (accumulates in the snowpack) based on air temperature.</p> <p>Step 3: Thermal state update. The snowpack's thermal state evolves toward the current air temperature. A cold snowpack \"remembers\" previous cold periods and must warm before melting.</p> <p>Step 4: Melt calculation. When the thermal state reaches freezing and air temperature exceeds freezing, melt occurs. The melt rate depends on temperature (degree-day factor) and snowpack size (small snowpacks melt faster per unit mass).</p> <p>Step 5: Aggregation. Rain and melt from all elevation bands sum to give total effective precipitation for the hydrological model.</p>"},{"location":"concepts/snow-models/#parameters","title":"Parameters","text":"<p>CemaNeige has three parameters:</p> Parameter Description Range Units Physical Interpretation \\(C_{TG}\\) Thermal state coefficient 0\u20131 - Controls how quickly the snowpack temperature responds to air temperature. Higher values = more \"memory\" of past conditions. \\(K_f\\) Degree-day melt factor 0\u201320 mm/\u00b0C/day Melt rate per degree above freezing. Higher values = faster melt. \\(Q_{NBV}\\) Snowpack threshold 50\u2013800 mm Snowpack size for full melt efficiency. Below this, melt proceeds more slowly. <p>Understanding the parameters:</p> <ul> <li> <p>\\(C_{TG}\\) acts like thermal inertia. At \\(C_{TG} = 0\\), the snowpack instantly matches air temperature. At \\(C_{TG} = 1\\), the snowpack never responds (unrealistic). Typical values are 0.2\u20130.5.</p> </li> <li> <p>\\(K_f\\) varies by climate and terrain. Values around 3\u20135 mm/\u00b0C/day are typical for mid-latitude mountain catchments. Forested areas tend to have lower values due to shading.</p> </li> <li> <p>**\\(Q_{NBV}\\) controls the transition from patchy to continuous snow cover. A small snowpack melts efficiently (high surface area relative to volume), while a deep snowpack melts at the full rate.</p> </li> </ul>"},{"location":"concepts/snow-models/#mathematical-formulation","title":"Mathematical Formulation","text":""},{"location":"concepts/snow-models/#temperature-lapse-rate","title":"Temperature Lapse Rate","text":"<p>For each elevation band \\(i\\) with elevation \\(z_i\\) and median catchment elevation \\(z_{median}\\):</p> \\[\\Delta z_i = \\frac{z_i - z_{median}}{100}\\] <p>The temperature at each band is adjusted using a day-of-year-dependent lapse rate \\(\\theta_{doy}\\):</p> \\[T_i = T_{measured} + \\theta_{doy} \\cdot \\Delta z_i\\] <p>The lapse rate varies seasonally, typically ranging from -0.4 to -0.5 \u00b0C per 100 m elevation.</p>"},{"location":"concepts/snow-models/#rain-snow-partitioning","title":"Rain-Snow Partitioning","text":"<p>The fraction of precipitation falling as snow depends on temperature:</p> \\[f_{solid} = \\begin{cases} 1 &amp; T_i &lt; -1\u00b0C \\\\ 1 - \\frac{T_i + 1}{4} &amp; -1\u00b0C \\leq T_i \\leq 3\u00b0C \\\\ 0 &amp; T_i &gt; 3\u00b0C \\end{cases}\\] <p>Precipitation partitions as:</p> \\[P_{snow,i} = f_{solid} \\cdot P_i\\] \\[P_{rain,i} = (1 - f_{solid}) \\cdot P_i\\] <p>The snowpack accumulates:</p> \\[SWE_i \\leftarrow SWE_i + P_{snow,i}\\]"},{"location":"concepts/snow-models/#thermal-state-evolution","title":"Thermal State Evolution","text":"<p>The thermal state \\(U_i\\) evolves as an exponential filter:</p> \\[U_i \\leftarrow \\min\\left(C_{TG} \\cdot U_i + (1 - C_{TG}) \\cdot T_i, \\, 0\\right)\\] <p>The thermal state is bounded at 0\u00b0C (once the snowpack reaches melting temperature, it cannot get warmer without melting).</p>"},{"location":"concepts/snow-models/#snowmelt-calculation","title":"Snowmelt Calculation","text":"<p>Melt occurs only when the thermal state reaches freezing (\\(U_i \\geq 0\\)) and air temperature exceeds the threshold (\\(T_i &gt; 0\\)):</p> <p>Potential melt:</p> \\[M_{pot,i} = K_f \\cdot (T_i - 0)\\] <p>Melt efficiency factor:</p> \\[f_{NTS,i} = \\min\\left(\\frac{SWE_i}{0.9 \\cdot Q_{NBV}}, 1\\right)\\] \\[f_{melt,i} = 0.9 \\cdot f_{NTS,i} + 0.1\\] <p>This ensures melt efficiency ranges from 0.1 (nearly bare ground) to 1.0 (full snowpack).</p> <p>Actual melt:</p> \\[M_i = \\min(M_{pot,i} \\cdot f_{melt,i}, \\, SWE_i)\\] \\[SWE_i \\leftarrow SWE_i - M_i\\]"},{"location":"concepts/snow-models/#effective-precipitation","title":"Effective Precipitation","text":"<p>Total effective precipitation for the hydrological model:</p> \\[P_{eff} = \\sum_i \\left(P_{rain,i} + M_i\\right)\\]"},{"location":"concepts/snow-models/#elevation-layers","title":"Elevation Layers","text":"<p>CemaNeige uses elevation layers to represent the temperature gradient within a catchment. Each layer receives the same precipitation but has different temperature based on its elevation.</p> <p>Why elevation layers matter:</p> <ol> <li> <p>Temperature varies with elevation. At a typical lapse rate of -0.5\u00b0C/100m, a catchment spanning 1000m elevation difference has a 5\u00b0C temperature gradient.</p> </li> <li> <p>Snow accumulates at high elevations while rain falls below. A single catchment-average temperature would miss this critical spatial pattern.</p> </li> <li> <p>Melt timing differs by elevation. Low-elevation snow melts first, followed progressively by higher elevations, spreading the melt season over time.</p> </li> </ol> <p>HOLMES implementation: The number of elevation layers and their properties are defined in the catchment data file (CemaNeigeInfo.csv), which specifies the fraction of catchment area at each elevation and the median elevation of each band.</p>"},{"location":"concepts/snow-models/#practical-considerations","title":"Practical Considerations","text":""},{"location":"concepts/snow-models/#when-to-enable-cemaneige","title":"When to Enable CemaNeige","text":"<p>Enable CemaNeige when:</p> <ul> <li>The catchment experiences significant snowfall (&gt;10% of annual precipitation)</li> <li>You observe a snowmelt-driven spring flood</li> <li>The catchment contains high-elevation areas where winter precipitation accumulates</li> </ul> <p>Skip CemaNeige when:</p> <ul> <li>The catchment rarely receives snow</li> <li>Temperatures seldom drop below freezing</li> <li>You're working in tropical or subtropical climates</li> </ul>"},{"location":"concepts/snow-models/#interpreting-parameter-values","title":"Interpreting Parameter Values","text":"<ul> <li>Low \\(C_{TG}\\) (0.1\u20130.3): Snowpack responds quickly to temperature changes. Appropriate for shallow snowpacks or maritime climates.</li> <li>High \\(C_{TG}\\) (0.4\u20130.6): Snowpack responds slowly. Appropriate for deep, continental snowpacks.</li> <li>Low \\(K_f\\) (1\u20133): Slow melt rates. Forested catchments, high latitude, or shaded terrain.</li> <li>High \\(K_f\\) (5\u201310): Fast melt rates. Open terrain, strong solar radiation.</li> </ul>"},{"location":"concepts/snow-models/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Too early melt: If simulated streamflow peaks before observed, try increasing \\(C_{TG}\\) (more thermal inertia) or decreasing \\(K_f\\) (slower melt).</p> </li> <li> <p>Too late melt: If simulated streamflow peaks after observed, try decreasing \\(C_{TG}\\) or increasing \\(K_f\\).</p> </li> <li> <p>Wrong melt duration: If melt is too concentrated or too spread out, adjust \\(Q_{NBV}\\). Higher values spread melt over a longer period.</p> </li> <li> <p>Elevation data: Ensure elevation bands properly represent the catchment's hypsometry (distribution of area with elevation).</p> </li> </ol>"},{"location":"concepts/snow-models/#references","title":"References","text":"<p>Val\u00e9ry, A., Andr\u00e9assian, V., &amp; Perrin, C. (2014). 'As simple as possible but not simpler': What is useful in a temperature-based snow-accounting routine? Part 2 \u2013 Sensitivity analysis of the Cemaneige snow accounting routine on 380 catchments. Journal of Hydrology, 517, 1176-1187. https://doi.org/10.1016/j.jhydrol.2014.04.058</p> <p>This paper presents the sensitivity analysis of CemaNeige across hundreds of catchments, providing guidance on parameter ranges and model behavior.</p> <p>Val\u00e9ry, A., Andr\u00e9assian, V., &amp; Perrin, C. (2014). 'As simple as possible but not simpler': What is useful in a temperature-based snow-accounting routine? Part 1 \u2013 Comparison of six snow accounting routines on 380 catchments. Journal of Hydrology, 517, 1166-1175. https://doi.org/10.1016/j.jhydrol.2014.04.059</p> <p>The companion paper comparing CemaNeige to other snow models, demonstrating its effectiveness despite its simplicity.</p>"},{"location":"data-formats/","title":"Data Formats","text":"<p>HOLMES uses CSV files for input data and exports results in both CSV and JSON formats.</p>"},{"location":"data-formats/#input-files","title":"Input Files","text":"<p>Input data files must be placed in the <code>src/holmes/data/</code> directory. Each catchment requires:</p> File Required Description <code>&lt;Catchment&gt;_Observations.csv</code> Yes Daily hydrometeorological observations <code>&lt;Catchment&gt;_CemaNeigeInfo.csv</code> No Snow model configuration (required for CemaNeige) <code>&lt;Catchment&gt;_Projections.csv</code> No Climate projection data <p>The catchment name in the filename determines how it appears in the application.</p>"},{"location":"data-formats/#export-files","title":"Export Files","text":"<p>HOLMES can export results from calibration, simulation, and projection pages. See Exported Files for detailed format specifications.</p> Page Files Format Calibration Parameters, results, timeseries JSON, JSON, CSV Simulation Results, timeseries JSON, CSV Projection Timeseries, results CSV, CSV"},{"location":"data-formats/cemaneige-info/","title":"CemaNeige Info","text":"<p>Configuration file for the CemaNeige snow model. Required when using snow modeling.</p>"},{"location":"data-formats/cemaneige-info/#file-naming","title":"File Naming","text":"<pre><code>&lt;Catchment&gt;_CemaNeigeInfo.csv\n</code></pre> <p>Example: <code>Au Saumon_CemaNeigeInfo.csv</code></p>"},{"location":"data-formats/cemaneige-info/#format","title":"Format","text":"<p>Key-value pairs in CSV format (no header row).</p>"},{"location":"data-formats/cemaneige-info/#required-keys","title":"Required Keys","text":"Key Description Units <code>QNBV</code> Mean annual solid precipitation mm/year <code>AltiBand</code> Altitude band boundaries m (semicolon-separated) <code>Z50</code> Median catchment altitude m <code>Lat</code> Catchment latitude degrees"},{"location":"data-formats/cemaneige-info/#example","title":"Example","text":"<pre><code>QNBV,354.9\nAltiBand,379;433;474;532;672\nZ50,474\nLat,45.482\n</code></pre>"},{"location":"data-formats/cemaneige-info/#notes","title":"Notes","text":"<ul> <li><code>AltiBand</code> values define the boundaries of elevation bands, separated by semicolons</li> <li>The number of altitude layers is determined by the number of values in <code>AltiBand</code></li> <li><code>QNBV</code> (Quantit\u00e9 de Neige du Bassin Versant) represents average annual snowfall</li> <li><code>Z50</code> is the median elevation, used for temperature lapse rate calculations</li> <li><code>Lat</code> (latitude) is used for day length calculations in the snow model</li> </ul>"},{"location":"data-formats/exports/","title":"Exported Files","text":"<p>HOLMES exports results in CSV and JSON formats from calibration, simulation, and projection pages.</p>"},{"location":"data-formats/exports/#calibration-exports","title":"Calibration Exports","text":""},{"location":"data-formats/exports/#parameters-json","title":"Parameters (JSON)","text":"<p>Filename: <code>&lt;catchment&gt;_&lt;model&gt;_params.json</code></p> <p>Contains the calibration configuration and optimized parameters.</p> <pre><code>{\n  \"catchment\": \"Au Saumon\",\n  \"hydroModel\": \"gr4j\",\n  \"snowModel\": \"cemaneige\",\n  \"objective\": \"nse\",\n  \"start\": \"1980-01-01\",\n  \"end\": \"1990-12-31\",\n  \"hydroParams\": {\n    \"X1\": 350.2,\n    \"X2\": -0.5,\n    \"X3\": 90.1,\n    \"X4\": 1.5\n  }\n}\n</code></pre>"},{"location":"data-formats/exports/#results-json","title":"Results (JSON)","text":"<p>Filename: <code>&lt;catchment&gt;_&lt;model&gt;_calibration_results.json</code></p> <p>Contains the optimization history with parameters and objective values at each iteration.</p> <pre><code>{\n  \"parameters\": [\n    {\"X1\": 300.0, \"X2\": 0.0, \"X3\": 50.0, \"X4\": 1.0},\n    {\"X1\": 350.2, \"X2\": -0.5, \"X3\": 90.1, \"X4\": 1.5}\n  ],\n  \"nse\": [0.65, 0.82]\n}\n</code></pre>"},{"location":"data-formats/exports/#timeseries-csv","title":"Timeseries (CSV)","text":"<p>Filename: <code>&lt;catchment&gt;_&lt;model&gt;_calibration_data.csv</code></p> <p>Daily observed and simulated streamflow.</p> <pre><code>date,observation,simulation\n1980-01-01,0.63,0.58\n1980-01-02,0.58,0.55\n</code></pre>"},{"location":"data-formats/exports/#simulation-exports","title":"Simulation Exports","text":""},{"location":"data-formats/exports/#results-json_1","title":"Results (JSON)","text":"<p>Filename: <code>&lt;catchment&gt;_simulation_results.json</code></p> <p>Contains configuration and performance metrics for all simulations.</p> <pre><code>{\n  \"calibrationConfig\": [\n    {\n      \"name\": \"simulation_1\",\n      \"catchment\": \"Au Saumon\",\n      \"hydroModel\": \"gr4j\",\n      \"params\": [350.2, -0.5, 90.1, 1.5]\n    }\n  ],\n  \"config\": {\n    \"start\": \"1991-01-01\",\n    \"end\": \"2000-12-31\"\n  },\n  \"results\": {\n    \"nse\": [0.78],\n    \"kge\": [0.81]\n  }\n}\n</code></pre>"},{"location":"data-formats/exports/#timeseries-csv_1","title":"Timeseries (CSV)","text":"<p>Filename: <code>&lt;catchment&gt;_simulation_data.csv</code></p> <p>Daily streamflow with columns for each simulation and observations.</p> <pre><code>date,simulation_1,simulation_2,observation\n1991-01-01,0.45,0.48,0.52\n1991-01-02,0.42,0.44,0.49\n</code></pre>"},{"location":"data-formats/exports/#projection-exports","title":"Projection Exports","text":""},{"location":"data-formats/exports/#timeseries-csv_2","title":"Timeseries (CSV)","text":"<p>Filename: <code>&lt;catchment&gt;_projection_data.csv</code></p> <p>Daily simulated streamflow for the selected projection scenario.</p> <pre><code>date,streamflow,model,horizon,scenario\n2050-01-01,0.32,CSI,2050,RCP45\n2050-01-02,0.35,CSI,2050,RCP45\n</code></pre>"},{"location":"data-formats/exports/#results-csv","title":"Results (CSV)","text":"<p>Filename: <code>&lt;catchment&gt;_projection_results.csv</code></p> <p>Summary metrics for each ensemble member.</p> <pre><code>member,winter_min,summer_min,spring_max,autumn_max,mean\n1,0.12,0.08,2.45,1.89,0.65\n2,0.15,0.09,2.31,1.76,0.62\n</code></pre>"},{"location":"data-formats/observations/","title":"Observations CSV","text":"<p>Daily hydrometeorological observation data for a catchment.</p>"},{"location":"data-formats/observations/#file-naming","title":"File Naming","text":"<pre><code>&lt;Catchment&gt;_Observations.csv\n</code></pre> <p>Example: <code>Au Saumon_Observations.csv</code></p>"},{"location":"data-formats/observations/#format","title":"Format","text":"<p>Standard CSV with header row. Date format must be <code>YYYY-MM-DD</code>.</p>"},{"location":"data-formats/observations/#required-columns","title":"Required Columns","text":"Column Description Units <code>Date</code> Observation date YYYY-MM-DD <code>P</code> Precipitation mm/day <code>E0</code> Potential evapotranspiration mm/day <code>Qo</code> Observed streamflow mm/day"},{"location":"data-formats/observations/#optional-columns","title":"Optional Columns","text":"Column Description Units Required For <code>T</code> Mean daily temperature \u00b0C Snow modeling (CemaNeige)"},{"location":"data-formats/observations/#example","title":"Example","text":"<pre><code>Date,P,E0,Qo,T\n1975-03-01,7.67,0.102,0.63,-3.75\n1975-03-02,2.26,0.0,0.58,-5.7\n1975-03-03,13.69,0.0,0.54,-7.2\n1975-03-04,0.0,0.0,0.49,-10.56\n</code></pre>"},{"location":"data-formats/observations/#notes","title":"Notes","text":"<ul> <li>All values should be in consistent units (mm/day for water fluxes)</li> <li>Missing temperature data disables snow modeling for the catchment</li> <li>The available date range is automatically detected from the file</li> <li>A warmup period (default 3 years) is used before the analysis period</li> </ul>"},{"location":"data-formats/projections/","title":"Projections CSV","text":"<p>Climate projection data for future scenario analysis.</p>"},{"location":"data-formats/projections/#file-naming","title":"File Naming","text":"<pre><code>&lt;Catchment&gt;_Projections.csv\n</code></pre> <p>Example: <code>Au Saumon_Projections.csv</code></p>"},{"location":"data-formats/projections/#format","title":"Format","text":"<p>Standard CSV with header row. Contains multiple ensemble members, scenarios, and time horizons.</p>"},{"location":"data-formats/projections/#required-columns","title":"Required Columns","text":"Column Description Units/Values <code>date</code> Projection date YYYY-MM-DD <code>precipitation</code> Daily precipitation mm/day <code>temperature</code> Mean daily temperature \u00b0C <code>member</code> Ensemble member number integer <code>scenario</code> Climate scenario e.g., <code>REF</code>, <code>RCP45</code>, <code>RCP85</code> <code>model</code> Climate model name e.g., <code>CSI</code>, <code>CRCM5</code> <code>horizon</code> Time horizon e.g., <code>REF</code>, <code>2050</code>, <code>2080</code>"},{"location":"data-formats/projections/#example","title":"Example","text":"<pre><code>date,precipitation,temperature,member,scenario,model,horizon\n1968-01-02,1.047,-4.488,10,REF,CSI,REF\n1968-01-03,2.061,-5.056,10,REF,CSI,REF\n1968-01-04,1.416,-14.492,10,REF,CSI,REF\n1968-01-05,0.352,-15.485,10,REF,CSI,REF\n</code></pre>"},{"location":"data-formats/projections/#notes","title":"Notes","text":"<ul> <li>The <code>REF</code> scenario/horizon typically represents the reference (historical) period</li> <li>Multiple ensemble members allow uncertainty quantification</li> <li>The projection page filters data by model, scenario, and horizon selections</li> <li>PET is calculated internally using the Oudin method from temperature and latitude</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Welcome to HOLMES (HydrOLogical Modeling Educational Software), a web-based tool designed to teach operational hydrology. This section will guide you through installing HOLMES and getting your first model calibration running.</p>"},{"location":"getting-started/#what-is-holmes","title":"What is HOLMES?","text":"<p>HOLMES is educational software developed at Universit\u00e9 Laval, Qu\u00e9bec, Canada. It provides an interactive web interface for:</p> <ul> <li>Calibrating hydrological models (GR4J, Bucket) against observed streamflow data</li> <li>Simulating streamflow using calibrated model parameters</li> <li>Projecting future streamflow under climate change scenarios</li> </ul>"},{"location":"getting-started/#what-youll-learn","title":"What You'll Learn","text":"<p>This Getting Started guide covers:</p> Section Description Installation Installing HOLMES via pip or from source Quickstart Your first calibration in 5 steps Configuration Customizing server settings"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<p>Before installing HOLMES, ensure you have:</p> <ul> <li>Python 3.11 or newer installed on your system</li> <li>A modern web browser (Chrome, Firefox, Safari, or Edge)</li> </ul>"},{"location":"getting-started/#quick-install","title":"Quick Install","text":"<p>Install HOLMES with:</p> <pre><code>pip install holmes-hydro\n</code></pre> <p>Then start the server:</p> <pre><code>holmes\n</code></pre> <p>The web interface opens automatically in your default browser. If needed, you can also access it manually at http://127.0.0.1:8000.</p> <p>For detailed installation instructions, see the Installation page.</p>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Follow the Quickstart tutorial to run your first calibration</li> <li>Read the User Guide for comprehensive interface documentation</li> <li>Explore the Concepts section to understand the hydrological models</li> </ul>"},{"location":"getting-started/configuration/","title":"Configuration","text":"<p>HOLMES can be customized using environment variables. These control server behavior such as the host address, port, and development features.</p>"},{"location":"getting-started/configuration/#configuration-file","title":"Configuration File","text":"<p>Create a <code>.env</code> file in your working directory to set configuration options:</p> <pre><code>DEBUG=True\nRELOAD=True\nHOST=127.0.0.1\nPORT=8000\n</code></pre>"},{"location":"getting-started/configuration/#available-options","title":"Available Options","text":""},{"location":"getting-started/configuration/#debug","title":"DEBUG","text":"<p>Enables debug mode with more verbose logging.</p> Property Value Type Boolean Default <code>False</code> Values <code>True</code>, <code>False</code> <pre><code>DEBUG=True\n</code></pre> <p>When enabled:</p> <ul> <li>More detailed error messages</li> <li>Verbose logging output</li> <li>Useful for troubleshooting issues</li> </ul>"},{"location":"getting-started/configuration/#reload","title":"RELOAD","text":"<p>Enables auto-reload on code changes. Primarily useful for development.</p> Property Value Type Boolean Default <code>False</code> Values <code>True</code>, <code>False</code> <pre><code>RELOAD=True\n</code></pre> <p>When enabled:</p> <ul> <li>Server automatically restarts when source files change</li> <li>Useful when developing or customizing HOLMES</li> </ul> <p>Development Only</p> <p>Do not enable <code>RELOAD</code> in production environments as it impacts performance.</p>"},{"location":"getting-started/configuration/#host","title":"HOST","text":"<p>The network interface to bind the server to.</p> Property Value Type String (IP address) Default <code>127.0.0.1</code> <pre><code>HOST=127.0.0.1\n</code></pre> <p>Common values:</p> <ul> <li><code>127.0.0.1</code> - Only accessible from local machine (recommended for personal use)</li> <li><code>0.0.0.0</code> - Accessible from any network interface (use for sharing on a network)</li> </ul> <p>Network Security</p> <p>Setting <code>HOST=0.0.0.0</code> exposes HOLMES to your network. Only use this on trusted networks and consider firewall rules.</p>"},{"location":"getting-started/configuration/#port","title":"PORT","text":"<p>The port number for the web server.</p> Property Value Type Integer Default <code>8000</code> Range <code>1</code>-<code>65535</code> <pre><code>PORT=8000\n</code></pre> <p>Port Conflicts</p> <p>If port 8000 is already in use by another application, change to an alternative like <code>8001</code> or <code>8080</code>.</p>"},{"location":"getting-started/configuration/#example-configurations","title":"Example Configurations","text":""},{"location":"getting-started/configuration/#personal-use-default","title":"Personal Use (Default)","text":"<p>Minimal configuration for local use:</p> <pre><code># .env - Personal use\n# No file needed, defaults are fine\n</code></pre> <p>Or explicitly:</p> <pre><code>HOST=127.0.0.1\nPORT=8000\n</code></pre>"},{"location":"getting-started/configuration/#development","title":"Development","text":"<p>Configuration for developing HOLMES:</p> <pre><code># .env - Development\nDEBUG=True\nRELOAD=True\n</code></pre>"},{"location":"getting-started/configuration/#classroomlab-setting","title":"Classroom/Lab Setting","text":"<p>Share HOLMES with students on a local network:</p> <pre><code># .env - Classroom\nHOST=0.0.0.0\nPORT=8000\n</code></pre> <p>Students can then access HOLMES at <code>http://&lt;your-ip&gt;:8000</code>.</p>"},{"location":"getting-started/configuration/#applying-configuration","title":"Applying Configuration","text":"<p>Configuration changes require restarting the server:</p> <ol> <li>Stop the running server (Ctrl+C)</li> <li>Edit or create the <code>.env</code> file</li> <li>Restart the server: <code>holmes</code></li> </ol>"},{"location":"getting-started/configuration/#environment-variables","title":"Environment Variables","text":"<p>Instead of a <code>.env</code> file, you can set environment variables directly:</p> Linux/macOSWindows (PowerShell)Windows (CMD) <pre><code>export PORT=8080\nholmes\n</code></pre> <pre><code>$env:PORT = \"8080\"\nholmes\n</code></pre> <pre><code>set PORT=8080\nholmes\n</code></pre> <p>Environment variables take precedence over <code>.env</code> file values.</p>"},{"location":"getting-started/configuration/#validation","title":"Validation","text":"<p>HOLMES validates configuration values on startup. Invalid values result in a startup error:</p> <pre><code>HolmesConfigError: Invalid port: -1. Port must be between 1 and 65535.\n</code></pre> <p>Check the error message and correct your configuration.</p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>HOLMES can be installed via pip (recommended for users) or from source (for development).</p>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.11 or newer</li> <li>A modern web browser</li> <li>Operating systems: Linux, macOS, or Windows</li> </ul>"},{"location":"getting-started/installation/#installing-via-pip","title":"Installing via pip","text":"<p>The simplest way to install HOLMES is using pip:</p> <pre><code>pip install holmes-hydro\n</code></pre> <p>This installs both the <code>holmes-hydro</code> Python package and the <code>holmes-rs</code> Rust extension that provides high-performance model computations.</p>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<p>After installation, verify that HOLMES is correctly installed:</p> <pre><code>holmes --version\n</code></pre> <p>This should display the installed version number.</p>"},{"location":"getting-started/installation/#installing-from-source","title":"Installing from Source","text":"<p>For development or to access the latest features, install from the GitHub repository.</p>"},{"location":"getting-started/installation/#step-1-install-uv","title":"Step 1: Install uv","text":"<p>HOLMES uses uv for package management:</p> Linux/macOSWindows <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <pre><code>powershell -ExecutionPolicy ByPass -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n</code></pre>"},{"location":"getting-started/installation/#step-2-clone-the-repository","title":"Step 2: Clone the Repository","text":"<pre><code>git clone https://github.com/antoinelb/holmes.git\ncd holmes\n</code></pre>"},{"location":"getting-started/installation/#step-3-install-dependencies","title":"Step 3: Install Dependencies","text":"<pre><code>uv sync\n</code></pre> <p>This creates a virtual environment and installs all dependencies, including building the Rust extension.</p>"},{"location":"getting-started/installation/#step-4-run-holmes","title":"Step 4: Run HOLMES","text":"<p>With the virtual environment activated:</p> <pre><code>uv run holmes\n</code></pre> <p>Or activate the environment first:</p> <pre><code>source .venv/bin/activate  # Linux/macOS\n# .venv\\Scripts\\activate   # Windows\nholmes\n</code></pre>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#common-issues","title":"Common Issues","text":""},{"location":"getting-started/installation/#command-not-found-holmes","title":"\"Command not found: holmes\"","text":"<p>If you installed via pip but the <code>holmes</code> command isn't found:</p> <ol> <li>Ensure your Python scripts directory is in your PATH</li> <li>Try running with the full path: <code>python -m holmes</code></li> </ol>"},{"location":"getting-started/installation/#rust-compilation-errors","title":"Rust Compilation Errors","text":"<p>If installing from source and encountering Rust errors:</p> <ol> <li>Ensure you have Rust installed: <code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh</code></li> <li>Update Rust: <code>rustup update</code></li> <li>Retry the installation</li> </ol>"},{"location":"getting-started/installation/#port-already-in-use","title":"Port Already in Use","text":"<p>If port 8000 is already occupied:</p> <pre><code># Create a .env file to use a different port\necho \"PORT=8001\" &gt; .env\nholmes\n</code></pre> <p>See Configuration for more options.</p>"},{"location":"getting-started/installation/#getting-help","title":"Getting Help","text":"<p>If you encounter issues:</p> <ol> <li>Check the GitHub Issues for known problems</li> <li>Open a new issue with your error message and system information</li> </ol>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Follow the Quickstart to run your first calibration</li> <li>Configure the server using Configuration options</li> </ul>"},{"location":"getting-started/quickstart/","title":"Quickstart","text":"<p>This tutorial walks you through your first HOLMES session: starting the server, calibrating a hydrological model, and exporting your results.</p>"},{"location":"getting-started/quickstart/#step-1-start-the-server","title":"Step 1: Start the Server","text":"<p>Open a terminal and run:</p> <pre><code>holmes\n</code></pre> <p>The web interface opens automatically in your default browser. The terminal shows:</p> <pre><code>INFO:     Started server process [12345]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\nINFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\n</code></pre> <p>If the browser doesn't open automatically, navigate to http://127.0.0.1:8000.</p> <p></p>"},{"location":"getting-started/quickstart/#step-2-configure-your-model","title":"Step 2: Configure Your Model","text":"<p>The interface opens on the Calibration page. Configure your model using the settings on the left:</p>"},{"location":"getting-started/quickstart/#general-settings","title":"General Settings","text":"<ol> <li> <p>Hydrological model: Select a model to calibrate</p> <ul> <li>gr4j: The GR4J model - a popular 4-parameter model</li> <li>bucket: A simple bucket model for educational purposes</li> </ul> </li> <li> <p>Catchment: Select a catchment dataset</p> <ul> <li>HOLMES includes sample catchments for learning</li> </ul> </li> <li> <p>Snow model (optional): Enable snow modeling if the catchment has snow</p> <ul> <li>cemaneige: The CemaNeige degree-day snow model</li> <li>Available only for catchments with temperature data</li> </ul> </li> <li> <p>Objective criteria: Choose how to measure model performance</p> <ul> <li>nse: Nash-Sutcliffe Efficiency (most common)</li> <li>kge: Kling-Gupta Efficiency</li> <li>rmse: Root Mean Square Error</li> </ul> </li> <li> <p>Streamflow transformation: Apply a transformation to emphasize different flow regimes</p> <ul> <li>High flows: none: No transformation - emphasizes high flows</li> <li>Medium flows: sqrt: Square root - balanced focus</li> <li>Low flows: log: Logarithmic - emphasizes low flows</li> </ul> </li> <li> <p>Calibration start/end: Set the date range for calibration</p> <ul> <li>Use the \"Reset\" buttons to reset to the full available range</li> </ul> </li> <li> <p>Calibration algorithm: Choose between manual and automatic calibration</p> <ul> <li>Manual: Adjust parameters by hand using sliders</li> <li>Automatic - SCE: Let the SCE-UA algorithm find optimal parameters</li> </ul> </li> </ol>"},{"location":"getting-started/quickstart/#step-3-run-a-manual-calibration","title":"Step 3: Run a Manual Calibration","text":"<p>For your first calibration, start with manual mode to understand how parameters affect streamflow:</p> <ol> <li>Ensure Calibration algorithm is set to Manual</li> <li>Adjust the parameter sliders in the Manual calibration settings panel</li> <li>Click Run to see the simulated streamflow</li> </ol> <p>The chart on the right shows:</p> <ul> <li>observations: Measured streamflow (blue line)</li> <li>simulation: Model output with your parameters (green line)</li> <li>The objective function value (e.g., NSE) tells you how well the model matches observations</li> </ul> <p>Understanding Parameters</p> <p>Each model has different parameters. For GR4J:</p> <ul> <li>X1: Production store capacity (mm)</li> <li>X2: Groundwater exchange coefficient (mm/day)</li> <li>X3: Routing store capacity (mm)</li> <li>X4: Unit hydrograph time base (days)</li> </ul> <p>Try adjusting one parameter at a time to see its effect.</p>"},{"location":"getting-started/quickstart/#step-4-run-an-automatic-calibration","title":"Step 4: Run an Automatic Calibration","text":"<p>Once you understand manual calibration, try automatic optimization:</p> <ol> <li>Set Calibration algorithm to Automatic - SCE</li> <li>Adjust algorithm settings if desired (default values work well):<ul> <li>n_complexes: Number of complexes</li> <li>max_evaluations: Maximum function evaluations</li> <li>k_stop: Iterations to check for convergence</li> <li>p_convergence_threshold: Relative change threshold</li> <li>geometric_range_threshold: Parameter space convergence</li> </ul> </li> <li>Click Start calibration</li> </ol> <p>Watch as the algorithm iteratively improves the parameters. The charts update in real-time showing:</p> <ul> <li>Parameter evolution over iterations</li> <li>Objective function improvement</li> <li>Simulated vs. observed streamflow</li> </ul> <p>Click Stop calibration at any time to halt the process.</p> <p></p>"},{"location":"getting-started/quickstart/#step-5-export-your-results","title":"Step 5: Export Your Results","text":"<p>After calibration, export your results for use in simulation or projection:</p> <ol> <li> <p>Click Export parameters to save the calibrated parameters as JSON</p> <ul> <li>This file can be imported into the Simulation or Projection pages</li> <li>File format: <code>catchment_model_params.json</code></li> </ul> </li> <li> <p>Click Export data to save the complete calibration record:</p> <ul> <li>Parameter evolution during calibration (JSON)</li> <li>Timeseries data with observations and simulation (CSV)</li> </ul> </li> </ol>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<p>Now that you've completed your first calibration:</p> <ul> <li>Run a Simulation: Use your calibrated parameters on different time periods</li> <li>Create Projections: Explore how streamflow might change under climate scenarios</li> <li>Explore the Interface: Learn about all available features</li> <li>Understand the Models: Learn the theory behind GR4J and other models</li> </ul> <p>Saving Your Work</p> <p>HOLMES can automatically save your settings between sessions. Enable Allow save in the settings menu (hamburger icon, top right) to persist your configuration.</p>"},{"location":"reference/changelog/","title":"Changelog","text":""},{"location":"reference/changelog/#340-2026-01-31","title":"[3.4.0] - 2026-01-31","text":""},{"location":"reference/changelog/#added","title":"Added","text":"<ul> <li>CEQUEAU hydrological model support in model registry (<code>hydro.py</code>), config, and simulation dispatching</li> <li>Warmup period visual indicator (shaded rectangle with label) on simulation streamflow chart</li> </ul>"},{"location":"reference/changelog/#changed","title":"Changed","text":"<ul> <li>Parameter slider step precision increased from 0.1 to 0.01 for non-integer parameters</li> <li>Calibration bar chart x-axis tick labels are now limited to 10 to prevent overlapping when many iterations are displayed</li> </ul>"},{"location":"reference/changelog/#fixed","title":"Fixed","text":"<ul> <li>Calibration results view now detects stale parameter plots from a previously selected model and re-renders correctly</li> <li>Hydro parameters are explicitly cast to <code>float64</code> in manual calibration to prevent type errors</li> </ul>"},{"location":"reference/changelog/#documentation","title":"Documentation","text":"<ul> <li>Added CEQUEAU model documentation: overview, mathematical formulation from Perrin (2000), 9-parameter description, and differences from original 11-parameter CEQUEAU</li> <li>Added comprehensive Concepts documentation with mathematical formulations:</li> <li>GR4J model: production store, unit hydrographs, routing store equations</li> <li>Bucket model: linear reservoir theory, flow partitioning, comparison with GR4J</li> <li>CemaNeige snow model: degree-day method, thermal state, elevation layers</li> <li>Oudin PET: solar geometry calculations, extraterrestrial radiation</li> <li>SCE-UA calibration: algorithm steps, convergence criteria, practical guidance</li> <li>Performance metrics: RMSE, NSE, KGE definitions and interpretation</li> <li>Concepts overview: rainfall-runoff modeling introduction, modeling chain</li> <li>Added MathJax configuration for proper LaTeX equation rendering in documentation</li> <li>Added auto-generated API reference using mkdocstrings (generates docs from Python docstrings)</li> <li>Restructured API reference to mirror Python module hierarchy (one page per module)</li> <li>Improved function signature formatting with line wrapping and cross-references</li> <li>Written Data Formats documentation: input file formats (observations, CemaNeige info, projections) and export formats</li> <li>Fixed reference section to properly include CHANGELOG.md and LICENSE content using include-markdown</li> </ul>"},{"location":"reference/changelog/#338-2026-01-24","title":"[3.3.8] - 2026-01-24","text":""},{"location":"reference/changelog/#added_1","title":"Added","text":"<ul> <li>Warmup period exclusion from objective function calculations</li> <li><code>read_data()</code> now returns a tuple <code>(DataFrame, warmup_steps)</code> indicating rows before user-requested start date</li> <li>Calibration and simulation metrics are computed only on data after the warmup period</li> <li>SCE-UA calibration passes <code>warmup_steps</code> to Rust extension for consistent metric calculation</li> </ul>"},{"location":"reference/changelog/#changed_1","title":"Changed","text":"<ul> <li>MkDocs serve now defaults to port 8001 to avoid conflict with HOLMES on port 8000</li> </ul>"},{"location":"reference/changelog/#fixed_1","title":"Fixed","text":"<ul> <li>CSS selector specificity for warmup rectangle in calibration and simulation charts (changed <code>rect</code> to <code>.warmup-rect</code>)</li> <li>Simulation remove button icon stroke color now uses theme foreground color</li> </ul>"},{"location":"reference/changelog/#documentation_1","title":"Documentation","text":"<ul> <li>Added MkDocs Material documentation site with full navigation structure</li> <li>Created <code>mkdocs.yml</code> configuration with Material theme, dark mode, code copy, and MathJax</li> <li>Added landing page (<code>docs/index.md</code>) with features overview and quick start</li> <li>Added GitHub Actions workflow for automatic deployment to GitHub Pages</li> <li>Added <code>mkdocs-include-markdown-plugin</code> and <code>mkdocs-git-revision-date-localized-plugin</code> dependencies</li> <li>Written Getting Started guide: installation, quickstart tutorial, and configuration reference</li> <li>Written User Guide: interface overview, calibration, simulation, projection, and settings documentation</li> <li>Simplified documentation structure: removed Developer Guide section, flattened Concepts/Models and API Reference</li> <li>Added Documentation section to CLAUDE.md noting Rust docs location</li> </ul>"},{"location":"reference/changelog/#337-2026-01-17","title":"[3.3.7] - 2026-01-17","text":""},{"location":"reference/changelog/#added_2","title":"Added","text":"<ul> <li>Added \"Allow save\" button in settings to allow reading from saved configs</li> <li>Notifications confirming successful file downloads on calibration, simulation, and projection pages</li> <li>Brush zoom on calibration, simulation, and projection streamflow plots (drag to zoom, double-click to reset)</li> <li>Projection results metrics (winter min, summer min, spring max, autumn max, mean) calculation and scatter plot visualization</li> <li>Download of projection results CSV alongside projection timeseries</li> </ul>"},{"location":"reference/changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Fixed date icon in dark mode for chromium browsers</li> <li>Fixed notifications not being removed from the DOM due to missing <code>data-id</code> attribute</li> <li>Fixed handling of catchments with no snow data</li> <li>Config date validation when switching catchments now properly resets start/end if outside available range</li> <li>Simulation config \"Reset to default\" for end date was incorrectly setting to start instead of end</li> <li>Changing calibration parameters removes the simulation data</li> </ul>"},{"location":"reference/changelog/#336-2026-01-11","title":"[3.3.6] - 2026-01-11","text":""},{"location":"reference/changelog/#added_3","title":"Added","text":"<ul> <li>Labels for manual calibration parameter sliders showing parameter names</li> </ul>"},{"location":"reference/changelog/#changed_2","title":"Changed","text":"<ul> <li>Manual calibration settings layout now uses CSS grid for better alignment</li> </ul>"},{"location":"reference/changelog/#fixed_3","title":"Fixed","text":"<ul> <li>Race condition in simulation page when navigating before configuration data is loaded</li> </ul>"},{"location":"reference/changelog/#335-2026-01-11","title":"[3.3.5] - 2026-01-11","text":""},{"location":"reference/changelog/#removed","title":"Removed","text":"<ul> <li>WebSocket ping/pong heartbeat functionality from frontend and backend (unnecessary for application)</li> </ul>"},{"location":"reference/changelog/#334-2026-01-11","title":"[3.3.4] - 2026-01-11","text":""},{"location":"reference/changelog/#added_4","title":"Added","text":"<ul> <li>Custom exception hierarchy in <code>exceptions.py</code> for clearer error handling</li> <li>Input validation module in <code>validation.py</code></li> <li>WebSocket utilities in <code>utils/websocket.py</code></li> <li>Comprehensive unit tests achieving 100% code coverage:</li> <li><code>tests/unit/test_config.py</code> for config validation error handling</li> <li><code>tests/unit/utils/test_websocket.py</code> for WebSocket utilities</li> <li>Error handling tests in <code>test_data.py</code> for CSV parsing, permissions, and CemaNeige errors</li> <li>Error handling tests in <code>test_calibration.py</code>, <code>test_hydro.py</code>, <code>test_snow.py</code> for Rust exception handling</li> <li>HolmesDataError handling tests in API test files</li> </ul>"},{"location":"reference/changelog/#changed_3","title":"Changed","text":"<ul> <li>Updated API modules with improved error handling and validation</li> <li>Enhanced calibration, simulation, and projection endpoints</li> <li>Improved configuration handling in <code>config.py</code></li> <li>Better data loading patterns in <code>data.py</code></li> <li>Enhanced logging throughout the application</li> </ul>"},{"location":"reference/changelog/#fixed_4","title":"Fixed","text":"<ul> <li>Eager file existence checks in <code>data.py</code> for <code>read_catchment_data</code>, <code>read_projection_data</code>, and <code>_get_available_period</code> to properly handle missing files with lazy Polars operations</li> </ul>"},{"location":"reference/license/","title":"License","text":"<p>Copyright \u00a9 2025 Universit\u00e9 Laval</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"user-guide/","title":"User Guide","text":"<p>This guide provides comprehensive documentation for using the HOLMES web interface. Whether you're a student learning about hydrological modeling or an instructor teaching operational hydrology, this guide will help you make the most of HOLMES.</p>"},{"location":"user-guide/#overview","title":"Overview","text":"<p>HOLMES provides three main workflows, each accessible from the navigation menu:</p> Workflow Purpose Prerequisites Calibration Find optimal model parameters by fitting to observed data Catchment data Simulation Run the model with calibrated parameters on any time period Calibrated parameters Projection Explore future streamflow under climate change scenarios Calibrated parameters + Climate data"},{"location":"user-guide/#interface-structure","title":"Interface Structure","text":"<p>The HOLMES interface consists of:</p> <p></p> <ol> <li>Navigation Menu (top left corner) - Switch between Calibration, Simulation, and Projection</li> <li>Settings Menu (top right corner) - Theme toggle, data persistence, version info</li> <li>Configuration Panel (top) - Model and run settings</li> <li>Results Panel (bottom) - Charts and metrics</li> </ol>"},{"location":"user-guide/#typical-workflow","title":"Typical Workflow","text":"<p>A typical HOLMES session follows this pattern:</p> <ol> <li>Calibrate a model against observed streamflow data</li> <li>Export the calibrated parameters to a JSON file</li> <li>Simulate streamflow for validation periods or other catchments</li> <li>Project future conditions using climate model data</li> </ol>"},{"location":"user-guide/#quick-links","title":"Quick Links","text":""},{"location":"user-guide/#by-task","title":"By Task","text":"<ul> <li>Run my first calibration</li> <li>Use automatic optimization</li> <li>Compare multiple models</li> <li>Explore climate projections</li> <li>Export my results</li> <li>Change the theme</li> </ul>"},{"location":"user-guide/#by-feature","title":"By Feature","text":"<ul> <li>Understanding parameter sliders</li> <li>Interpreting performance metrics</li> <li>Zoom and pan on charts</li> <li>Save my settings between sessions</li> </ul>"},{"location":"user-guide/#user-guide-sections","title":"User Guide Sections","text":"<ul> <li> <p> Interface Overview</p> <p>Learn the common UI elements: navigation, charts, forms, and keyboard shortcuts</p> </li> <li> <p> Calibration</p> <p>Manual and automatic model calibration against observed data</p> </li> <li> <p> Simulation</p> <p>Forward model runs with calibrated parameters</p> </li> <li> <p> Projection</p> <p>Climate change impact assessment</p> </li> <li> <p> Settings</p> <p>Theme, data persistence, and other preferences</p> </li> </ul>"},{"location":"user-guide/calibration/","title":"Calibration","text":"<p>The Calibration page is where you find optimal model parameters by fitting simulations to observed streamflow data. HOLMES supports both manual parameter adjustment and automatic optimization.</p>"},{"location":"user-guide/calibration/#overview","title":"Overview","text":"<p>Calibration is the process of finding model parameters that produce simulated streamflow closely matching observations. HOLMES displays:</p> <ul> <li>Observed streamflow from the selected catchment</li> <li>Simulated streamflow using current parameters</li> <li>Performance metrics quantifying the fit</li> </ul> <p></p>"},{"location":"user-guide/calibration/#general-settings","title":"General Settings","text":"<p>The left panel contains configuration options that apply to both manual and automatic calibration.</p>"},{"location":"user-guide/calibration/#hydrological-model","title":"Hydrological Model","text":"<p>Select the rainfall-runoff model to calibrate:</p> Model Parameters gr4j 4 bucket 6 <p>See Concepts: Models for detailed model descriptions.</p>"},{"location":"user-guide/calibration/#catchment","title":"Catchment","text":"<p>Select the catchment dataset. Each catchment includes:</p> <ul> <li>Daily precipitation</li> <li>Potential evapotranspiration (PET)</li> <li>Observed streamflow</li> <li>Optionally: temperature (for snow modeling)</li> </ul> <p>The available date range updates based on the selected catchment.</p>"},{"location":"user-guide/calibration/#snow-model","title":"Snow Model","text":"<p>Enable snow accumulation and melt modeling for catchments with significant snowfall:</p> Option Description none No snow model (default) cemaneige CemaNeige degree-day model <p>Availability</p> <p>The snow model option is only enabled for catchments that include temperature data. Catchments without temperature data will show this option as disabled.</p>"},{"location":"user-guide/calibration/#objective-criteria","title":"Objective Criteria","text":"<p>Choose the metric used to evaluate model performance:</p> Metric Optimal Description nse 1 Nash-Sutcliffe Efficiency kge 1 Kling-Gupta Efficiency rmse 0 Root Mean Square Error"},{"location":"user-guide/calibration/#streamflow-transformation","title":"Streamflow Transformation","text":"<p>Apply a transformation to the streamflow before computing the objective:</p> Transformation Effect High flows: none No transformation - calibrates to match peak flows Medium flows: sqrt Square root - balanced emphasis on all flows Low flows: log Logarithmic - emphasizes base flow accuracy <p>Choosing a Transformation</p> <ul> <li>Use none if flood prediction is your primary goal</li> <li>Use sqrt for general-purpose calibration</li> <li>Use log if accurate low-flow simulation is critical (e.g., drought studies)</li> </ul>"},{"location":"user-guide/calibration/#calibration-period","title":"Calibration Period","text":"<p>Set the start and end dates for calibration:</p> <ul> <li>Dates are constrained to the catchment's data availability</li> <li>Click Reset to restore the full available range</li> <li>A warm-up period is automatically included before the start date</li> </ul> <p>Warm-up Period</p> <p>The warm-up period (3 years, or up to the minimum available data) allows model stores to reach realistic levels before the calibration period begins. This period is shown as a shaded area on the chart.</p>"},{"location":"user-guide/calibration/#calibration-algorithm","title":"Calibration Algorithm","text":"<p>Choose between manual and automatic calibration:</p> Algorithm Use Case Manual Learning, exploring parameter sensitivity Automatic - SCE Finding optimal parameters efficiently"},{"location":"user-guide/calibration/#manual-calibration","title":"Manual Calibration","text":"<p>Manual calibration lets you adjust parameters directly and see immediate results.</p> <p></p>"},{"location":"user-guide/calibration/#manual-calibration-settings","title":"Manual calibration settings","text":"<p>When Manual is selected, parameter sliders appear:</p> <p>For GR4J:</p> Parameter Description x1 Production store capacity (mm) x2 Groundwater exchange (mm/day) x3 Routing store capacity (mm) x4 Unit hydrograph time base (days) <p>For Bucket:</p> Parameter Description c_soil Soil storage capacity (mm) alpha Split factor for slow/fast routing k_r Slow reservoir recession coefficient delta Routing delay (days) beta Precipitation split factor k_t Fast reservoir recession coefficient"},{"location":"user-guide/calibration/#running-a-manual-calibration","title":"Running a Manual Calibration","text":"<ol> <li>Adjust parameter sliders to your desired values</li> <li>Click Run to execute the simulation</li> <li>Observe the streamflow chart and objective value</li> <li>Iterate: adjust parameters and run again</li> </ol> <p>Parameter Exploration</p> <p>Try adjusting one parameter at a time to understand its effect on model behavior. This builds intuition about how the model works.</p>"},{"location":"user-guide/calibration/#automatic-calibration","title":"Automatic Calibration","text":"<p>Automatic calibration uses optimization algorithms to find parameters that maximize (or minimize) the objective function.</p> <p></p>"},{"location":"user-guide/calibration/#automatic-sce-calibration-settings","title":"Automatic - SCE calibration settings","text":"<p>When Automatic - SCE is selected, algorithm parameters appear:</p> Parameter Description n_complexes Number of complexes max_evaluations Maximum function evaluations k_stop Iterations to check for convergence p_convergence_threshold Relative change threshold geometric_range_threshold Parameter space convergence <p>The Shuffled Complex Evolution (SCE-UA) algorithm is a global optimization method well-suited for hydrological model calibration.</p>"},{"location":"user-guide/calibration/#running-an-automatic-calibration","title":"Running an Automatic Calibration","text":"<ol> <li>Configure general settings and algorithm parameters</li> <li>Click Start calibration</li> <li>Watch the real-time updates:<ul> <li>Parameter values converging</li> <li>Objective function improving</li> <li>Simulated streamflow matching observations</li> </ul> </li> <li>Click Stop calibration to halt early, or wait for completion</li> </ol>"},{"location":"user-guide/calibration/#understanding-the-results","title":"Understanding the Results","text":"<p>During and after calibration, the results panel shows:</p> <p>Parameter Evolution Charts (one per parameter)</p> <ul> <li>X-axis: Iteration number</li> <li>Y-axis: Parameter value</li> <li>Shows how each parameter converges toward optimal</li> </ul> <p>Objective Function Chart</p> <ul> <li>X-axis: Iteration number</li> <li>Y-axis: Objective value (NSE, KGE, or RMSE)</li> <li>A horizontal line shows the optimal value (1 for NSE/KGE, 0 for RMSE)</li> </ul> <p>Streamflow Chart</p> <ul> <li>Blue line: Observed streamflow</li> <li>Green line: Simulated streamflow (updates with each iteration)</li> <li>Blue shaded area: Warm-up period (excluded from metrics)</li> </ul>"},{"location":"user-guide/calibration/#exporting-results","title":"Exporting Results","text":"<p>After calibration, export your results using the buttons below the settings:</p>"},{"location":"user-guide/calibration/#export-parameters","title":"Export parameters","text":"<p>Saves the calibrated parameters as a JSON file:</p> <pre><code>{\n  \"hydroModel\": \"gr4j\",\n  \"catchment\": \"Example Catchment\",\n  \"snowModel\": null,\n  \"objective\": \"nse\",\n  \"transformation\": \"sqrt\",\n  \"start\": \"1990-01-01\",\n  \"end\": \"2000-12-31\",\n  \"hydroParams\": {\n    \"x1\": 350.5,\n    \"x2\": 0.12,\n    \"x3\": 95.3,\n    \"x4\": 1.85\n  }\n}\n</code></pre> <p>This file can be imported into the Simulation or Projection pages.</p>"},{"location":"user-guide/calibration/#export-data","title":"Export data","text":"<p>Saves two files:</p> <ol> <li>Calibration results (JSON): Complete parameter evolution and objective values</li> <li>Timeseries data (CSV): Date, observed streamflow, simulated streamflow</li> </ol>"},{"location":"user-guide/calibration/#common-issues","title":"Common Issues","text":""},{"location":"user-guide/calibration/#poor-calibration-results","title":"Poor Calibration Results","text":"<p>If the objective value is far from optimal:</p> <ol> <li>Check that the correct catchment data is loaded</li> <li>Try a different transformation</li> <li>Verify the calibration period includes representative conditions</li> <li>Consider if the selected model is appropriate for this catchment</li> </ol>"},{"location":"user-guide/calibration/#calibration-not-converging","title":"Calibration Not Converging","text":"<p>If automatic calibration doesn't improve:</p> <ol> <li>Increase max_evaluations</li> <li>Try different initial conditions (run multiple times)</li> <li>Consider if the objective function is appropriate</li> </ol>"},{"location":"user-guide/calibration/#missing-snow-model-option","title":"Missing Snow Model Option","text":"<p>The snow model is only available for catchments with temperature data. Ensure your catchment includes temperature observations.</p>"},{"location":"user-guide/interface-overview/","title":"Interface Overview","text":"<p>This page describes the common elements of the HOLMES interface that appear across all pages.</p>"},{"location":"user-guide/interface-overview/#navigation","title":"Navigation","text":"<p>The navigation menu is accessed by clicking the grid icon in the top-left corner. It provides access to the three main pages:</p> Page Description Calibration Fit model parameters to observed streamflow Simulation Run forward simulations with calibrated parameters Projection Explore climate change scenarios <p>Click any page name to navigate there. Your current settings and data are preserved when switching pages (if Allow save is enabled in settings).</p>"},{"location":"user-guide/interface-overview/#page-layout","title":"Page Layout","text":"<p>Each page follows a consistent vertical layout, with sections flowing from top to bottom:</p>"},{"location":"user-guide/interface-overview/#header","title":"Header","text":"<p>The top area contains:</p> <ul> <li>Navigation menu (grid icon, top-left)</li> <li>Settings menu (hamburger icon, top-right)</li> </ul>"},{"location":"user-guide/interface-overview/#configuration-section","title":"Configuration Section","text":"<p>Below the header, configuration options appear:</p> <ul> <li>Form fields for selecting models, catchments, dates</li> <li>Parameter controls (sliders for manual calibration, inputs for algorithms)</li> <li>Action buttons (Run, Start, Stop, Export)</li> </ul>"},{"location":"user-guide/interface-overview/#results-section","title":"Results Section","text":"<p>Below the configuration, results are displayed:</p> <ul> <li>Time series charts showing observed and simulated streamflow</li> <li>Parameter evolution plots during calibration</li> <li>Performance metrics (NSE, KGE, etc.)</li> </ul>"},{"location":"user-guide/interface-overview/#form-elements","title":"Form Elements","text":""},{"location":"user-guide/interface-overview/#dropdowns","title":"Dropdowns","text":"<p>Select from predefined options:</p> <ul> <li>Hydrological model: Choose which model to use</li> <li>Catchment: Select the dataset</li> <li>Objective criteria: Choose the performance metric</li> </ul>"},{"location":"user-guide/interface-overview/#date-inputs","title":"Date Inputs","text":"<p>Set calibration/simulation periods:</p> <ul> <li>Click the field to open a date picker</li> <li>Use the Reset button to return to the full available range</li> <li>Dates are constrained to the catchment's data availability</li> </ul>"},{"location":"user-guide/interface-overview/#parameter-sliders","title":"Parameter Sliders","text":"<p>In manual calibration mode, sliders control model parameters:</p> <ul> <li>Drag the slider to adjust values</li> <li>The numeric input shows the current value</li> <li>Values are constrained between model-defined bounds</li> </ul>"},{"location":"user-guide/interface-overview/#checkboxes","title":"Checkboxes","text":"<p>Toggle options on/off:</p> <ul> <li>Multimodel simulation: Average multiple calibrations (Simulation page)</li> <li>Allow save: Persist settings between sessions (Settings)</li> </ul>"},{"location":"user-guide/interface-overview/#charts","title":"Charts","text":"<p>All charts in HOLMES share common interaction patterns.</p>"},{"location":"user-guide/interface-overview/#chart-interactions","title":"Chart Interactions","text":""},{"location":"user-guide/interface-overview/#zooming","title":"Zooming","text":"<p>Zoom into a specific time period:</p> <ol> <li>Click and drag horizontally to select a region</li> <li>Release to zoom to that selection</li> <li>Double-click anywhere to reset to the full view</li> </ol>"},{"location":"user-guide/interface-overview/#reading-values","title":"Reading Values","text":"<p>Hover over chart elements to see values. The legend identifies each line:</p> <ul> <li>Observations: Measured streamflow (blue)</li> <li>Simulation: Model output (green)</li> <li>Warmup period: Initial period excluded from metrics (blue shaded area)</li> </ul>"},{"location":"user-guide/interface-overview/#chart-types","title":"Chart Types","text":"Chart Description Found on Streamflow time series Observed vs simulated streamflow Calibration, Simulation Parameter evolution How parameters change during optimization Calibration (automatic) Objective function Performance metric improvement over iterations Calibration (automatic) Bar charts Performance metrics comparison Simulation Seasonal projection Daily mean streamflow by month Projection"},{"location":"user-guide/interface-overview/#notifications","title":"Notifications","text":"<p>HOLMES displays notifications at the top-center of the page:</p> <ul> <li>Success messages: Operation completed (default background)</li> <li>Error messages: Something went wrong (red/emphasized)</li> </ul> <p>Notifications automatically dismiss after a few seconds. Errors provide guidance on how to resolve the issue.</p>"},{"location":"user-guide/interface-overview/#loading-states","title":"Loading States","text":"<p>When HOLMES is processing:</p> <ul> <li>A loading indicator appears during data fetches and model runs</li> <li>Buttons may be disabled to prevent conflicting operations</li> <li>During automatic calibration, the Stop button replaces Start</li> </ul>"},{"location":"user-guide/interface-overview/#connection-status","title":"Connection Status","text":"<p>HOLMES uses WebSocket connections for real-time updates. If the connection is lost:</p> <ol> <li>HOLMES attempts to reconnect automatically</li> <li>If reconnection fails repeatedly, a notification advises refreshing the page</li> <li>Your local settings (if Allow save is enabled) are preserved in browser storage</li> </ol>"},{"location":"user-guide/interface-overview/#keyboard-shortcuts","title":"Keyboard Shortcuts","text":"Shortcut Action T Toggle theme (light/dark)"},{"location":"user-guide/interface-overview/#browser-compatibility","title":"Browser Compatibility","text":"<p>HOLMES works best with:</p> <ul> <li>Chrome/Edge (latest)</li> <li>Firefox (latest)</li> <li>Safari (latest)</li> </ul> <p>JavaScript must be enabled for the application to function.</p>"},{"location":"user-guide/interface-overview/#tips","title":"Tips","text":"<p>Data Persistence</p> <p>Enable Allow save in settings to remember your configuration between browser sessions. This is especially useful when working on the same catchment over multiple sessions.</p> <p>Multiple Tabs</p> <p>You can open HOLMES in multiple browser tabs to compare different configurations side-by-side. Note that tabs share the same localStorage, so changes in one tab may affect others after page refresh. Disable Allow save in settings to prevent this.</p>"},{"location":"user-guide/projection/","title":"Projection","text":"<p>The Projection page explores how streamflow might change under future climate scenarios. Using calibrated model parameters and climate model projections, you can assess potential impacts of climate change on water resources.</p>"},{"location":"user-guide/projection/#overview","title":"Overview","text":"<p>Climate projection simulates streamflow using:</p> <ol> <li>Calibrated model parameters from the Calibration page</li> <li>Future climate data from climate projections</li> </ol> <p>Results show potential changes in streamflow seasonality and magnitude under different climate scenarios and time horizons.</p> <p></p>"},{"location":"user-guide/projection/#prerequisites","title":"Prerequisites","text":"<p>Before using projections, you need:</p> <ol> <li>Calibrated parameters: Export from the Calibration page</li> <li>Projection data: Climate projections for your catchment (pre-loaded in HOLMES)</li> </ol> <p>Projection Data Availability</p> <p>Projection data is catchment-specific. Not all catchments have projection data available.</p>"},{"location":"user-guide/projection/#importing-calibration-results","title":"Importing Calibration Results","text":""},{"location":"user-guide/projection/#step-1-prepare-calibration","title":"Step 1: Prepare Calibration","text":"<ol> <li>Go to the Calibration page</li> <li>Calibrate a model for your catchment</li> <li>Click Export parameters to save the JSON file</li> </ol>"},{"location":"user-guide/projection/#step-2-import-to-projection","title":"Step 2: Import to Projection","text":"<p>On the Projection page:</p> <ol> <li>Click Import model parameters</li> <li>Select your calibration JSON file</li> <li>The calibration details appear in the table</li> </ol> <p>Single Calibration</p> <p>Unlike Simulation, the Projection page uses only one calibration at a time. Importing a new calibration replaces the existing one.</p>"},{"location":"user-guide/projection/#calibration-results-table","title":"Calibration Results Table","text":"<p>The table displays the imported calibration:</p> Field Description hydrological model GR4J, Bucket, etc. catchment Must match available projection data objective Calibration objective used transformation Streamflow transformation algorithm Manual or SCE date start Calibration period start date end Calibration period end snow model CemaNeige or none parameters Calibrated parameter values"},{"location":"user-guide/projection/#projection-settings","title":"Projection Settings","text":"<p>After importing a calibration, configure the projection:</p>"},{"location":"user-guide/projection/#climate-model","title":"Climate Model","text":"<p>Select the climate model that provides future climate data:</p> <ul> <li>Different models have different assumptions and biases</li> <li>Multiple models allow uncertainty assessment</li> </ul>"},{"location":"user-guide/projection/#horizon","title":"Horizon","text":"<p>Select the future time period. Available horizons depend on the projection data for your catchment (e.g., H20, H50, H80).</p>"},{"location":"user-guide/projection/#climate-scenario","title":"Climate Scenario","text":"<p>Select the climate scenario. Available scenarios depend on the projection data for your catchment (e.g., RCP4.5, RCP8.5, REF).</p>"},{"location":"user-guide/projection/#running-a-projection","title":"Running a Projection","text":"<ol> <li>Import a calibration result</li> <li>Select climate model, horizon, and scenario</li> <li>Click Run</li> </ol> <p>A loading indicator shows while the projection runs (this may take longer than calibration/simulation due to the longer time series).</p> <p></p>"},{"location":"user-guide/projection/#understanding-results","title":"Understanding Results","text":""},{"location":"user-guide/projection/#projection-chart","title":"Projection Chart","text":"<p>The main chart shows the mean daily hydrograph (averaged across all years in the projection period):</p> <ul> <li>X-axis: Month (January to December)</li> <li>Y-axis: Streamflow</li> <li>Light lines: Individual ensemble members</li> <li>Bold line: Median across all members</li> </ul> <p>This shows the expected seasonal pattern of streamflow under the selected scenario.</p>"},{"location":"user-guide/projection/#chart-interactions","title":"Chart Interactions","text":"<ul> <li>Zoom: Click and drag to select a time range</li> <li>Reset: Double-click to return to full year view</li> </ul>"},{"location":"user-guide/projection/#results-chart","title":"Results Chart","text":"<p>The dot plot shows summary statistics for each ensemble member:</p> Metric Description Winter min Minimum daily flow in January-March Spring max Maximum daily flow in March-June Summer min Minimum daily flow in May-October Autumn max Maximum daily flow in September-December Mean Annual mean streamflow <p>Each dot represents one ensemble member, showing the spread of projections.</p>"},{"location":"user-guide/projection/#interpreting-projections","title":"Interpreting Projections","text":""},{"location":"user-guide/projection/#ensemble-spread","title":"Ensemble Spread","text":"<p>The spread of ensemble members indicates uncertainty:</p> <ul> <li>Narrow spread: Models agree on the projection</li> <li>Wide spread: Significant uncertainty in the projection</li> </ul>"},{"location":"user-guide/projection/#seasonal-changes","title":"Seasonal Changes","text":"<p>Look for changes in:</p> <ul> <li>Peak timing: Has the spring freshet shifted earlier/later?</li> <li>Peak magnitude: Are floods projected to increase/decrease?</li> <li>Low flow timing: When do minimum flows occur?</li> <li>Low flow magnitude: Are droughts projected to worsen?</li> </ul>"},{"location":"user-guide/projection/#comparing-scenarios","title":"Comparing Scenarios","text":"<p>Run projections with different settings to understand:</p> <ul> <li>Horizon effect: How do projections change across different time horizons?</li> <li>Scenario effect: How do different climate scenarios compare?</li> <li>Model effect: Do different climate models agree?</li> </ul>"},{"location":"user-guide/projection/#exporting-results","title":"Exporting Results","text":"<p>Click Export data to save:</p> <ol> <li> <p>Projection timeseries (CSV): Daily mean streamflow by day of year</p> <pre><code>date,01,02,03,median,model,horizon,scenario\n2021-01-01,15.2,14.8,16.1,15.2,CSI,H50,RCP4.5\n2021-01-02,14.9,14.5,15.8,14.9,CSI,H50,RCP4.5\n...\n</code></pre> </li> <li> <p>Projection results (CSV): Summary statistics per member</p> <pre><code>member,winter_min,summer_min,spring_max,autumn_max,mean\n01,5.2,2.1,125.3,45.6,22.4\n02,4.8,1.9,118.7,42.3,21.1\n...\n</code></pre> </li> </ol>"},{"location":"user-guide/projection/#common-issues","title":"Common Issues","text":""},{"location":"user-guide/projection/#no-projection-data","title":"No Projection Data","text":"<p>If the projection settings don't appear after importing calibration:</p> <ul> <li>The catchment may not have projection data available</li> <li>Try a different catchment with projection data</li> </ul>"},{"location":"user-guide/projection/#long-run-times","title":"Long Run Times","text":"<p>Projections can take longer than calibration:</p> <ul> <li>Climate model data spans many years</li> <li>Multiple ensemble members are processed</li> <li>Wait for the loading indicator to complete</li> </ul>"},{"location":"user-guide/projection/#unexpected-results","title":"Unexpected Results","text":"<p>If projections seem unrealistic:</p> <ul> <li>Verify calibration quality first</li> <li>Check that the correct catchment was calibrated</li> <li>Consider if the model is appropriate for future conditions</li> </ul>"},{"location":"user-guide/settings/","title":"Settings","text":"<p>The Settings panel provides options to customize your HOLMES experience, including theme selection, data persistence, and application information.</p>"},{"location":"user-guide/settings/#accessing-settings","title":"Accessing Settings","text":"<p>Click the hamburger menu icon (three horizontal lines) in the top-right corner to open the settings panel.</p> <p></p>"},{"location":"user-guide/settings/#available-settings","title":"Available Settings","text":""},{"location":"user-guide/settings/#theme","title":"Theme","text":"<p>Toggle between light and dark color themes:</p> Theme Description Dark (default) Dark background with light text - easier on the eyes in low light Light Light background with dark text - better in bright environments <p>Click the theme button or press T to toggle.</p> <p>The theme preference is saved automatically if Allow save is enabled.</p>"},{"location":"user-guide/settings/#reset-all","title":"Reset All","text":"<p>Click Reset all to clear all saved settings and data:</p> <ul> <li>Clears all localStorage data for HOLMES</li> <li>Resets configuration to defaults</li> <li>Removes imported calibrations from Simulation and Projection pages</li> <li>Reloads the page</li> </ul> <p>Data Loss</p> <p>Reset all cannot be undone. Any unsaved calibration parameters or imported files will be lost.</p>"},{"location":"user-guide/settings/#allow-save","title":"Allow Save","text":"<p>Controls whether saved settings are loaded on page load:</p> State Behavior Enabled Saved settings are loaded from localStorage on page load Disabled Saved settings are ignored on page load (defaults are used instead) <p>When Allow save is disabled, saved settings are ignored on page load (defaults are used instead). However, changes you make during the session are still written to localStorage.</p> <p>Settings that can be persisted include:</p> <ul> <li>Selected model, catchment, objective, etc.</li> <li>Calibration date ranges</li> <li>Imported calibrations (Simulation/Projection pages)</li> <li>Theme preference</li> </ul>"},{"location":"user-guide/settings/#version","title":"Version","text":"<p>Displays the current HOLMES version number.</p> <p>This information is useful when:</p> <ul> <li>Reporting bugs or issues</li> <li>Checking for updates</li> <li>Verifying installation</li> </ul>"},{"location":"user-guide/settings/#keyboard-shortcuts","title":"Keyboard Shortcuts","text":"<p>The settings panel includes a visual reminder of available shortcuts:</p> Shortcut Action T Toggle theme"},{"location":"user-guide/settings/#data-storage","title":"Data Storage","text":"<p>HOLMES stores settings in your browser's localStorage under keys prefixed with <code>holmes--</code>:</p> <ul> <li><code>holmes--settings--theme</code>: Light or dark theme</li> <li><code>holmes--calibration--*</code>: Calibration page settings</li> <li><code>holmes--simulation--*</code>: Simulation page settings</li> <li><code>holmes--projection--*</code>: Projection page settings</li> </ul> <p>This data:</p> <ul> <li>Stays in your browser (not sent to any server)</li> <li>Persists until cleared manually or via Reset all</li> <li>Is specific to the browser and device you're using</li> </ul>"},{"location":"user-guide/settings/#privacy","title":"Privacy","text":"<p>HOLMES does not collect or transmit any user data:</p> <ul> <li>All computations happen locally or on your server</li> <li>Settings are stored only in your browser</li> <li>No analytics or tracking</li> </ul>"},{"location":"user-guide/settings/#closing-the-panel","title":"Closing the Panel","text":"<p>Click anywhere outside the settings panel to close it.</p>"},{"location":"user-guide/simulation/","title":"Simulation","text":"<p>The Simulation page lets you run the hydrological model forward in time using calibrated parameters. This is useful for model validation, comparing multiple calibrations, and testing parameter transferability.</p>"},{"location":"user-guide/simulation/#overview","title":"Overview","text":"<p>Simulation applies pre-calibrated parameters to generate streamflow predictions. Unlike calibration, simulation does not modify parameters - it simply runs the model and evaluates performance against observations.</p> <p>Common use cases:</p> <ul> <li>Validation: Test calibrated parameters on an independent time period</li> <li>Model comparison: Compare performance of different models or calibrations</li> <li>Multimodel averaging: Combine predictions from multiple calibrations</li> </ul> <p></p>"},{"location":"user-guide/simulation/#importing-calibration-results","title":"Importing Calibration Results","text":"<p>Before running a simulation, you must import one or more calibration result files.</p>"},{"location":"user-guide/simulation/#step-1-export-from-calibration","title":"Step 1: Export from Calibration","text":"<p>First, calibrate a model and export the parameters:</p> <ol> <li>Go to the Calibration page</li> <li>Complete a calibration (manual or automatic)</li> <li>Click Export parameters to save the JSON file</li> </ol>"},{"location":"user-guide/simulation/#step-2-import-to-simulation","title":"Step 2: Import to Simulation","text":"<p>On the Simulation page:</p> <ol> <li>Click Import model(s) parameters</li> <li>Select one or more calibration JSON files</li> <li>The imported calibrations appear in the table</li> </ol>"},{"location":"user-guide/simulation/#calibration-results-table","title":"Calibration Results Table","text":"<p>The table displays all imported calibrations:</p> Column Description hydrological model GR4J, Bucket, etc. catchment The catchment used for calibration objective Calibration objective (NSE, KGE, RMSE) transformation Streamflow transformation used algorithm Manual or SCE date start/end Calibration period snow model CemaNeige or none parameters Calibrated parameter values <p>Click the X button next to any calibration to remove it.</p> <p>Same Catchment Required</p> <p>All imported calibrations must be for the same catchment. Attempting to import a calibration for a different catchment will show an error.</p>"},{"location":"user-guide/simulation/#simulation-settings","title":"Simulation Settings","text":""},{"location":"user-guide/simulation/#simulation-period","title":"Simulation Period","text":"<p>Set the date range for simulation:</p> <ul> <li>Start: Beginning of the simulation period</li> <li>End: End of the simulation period</li> <li>Reset buttons: Return to the catchment's full available range</li> </ul> <p>Validation Period</p> <p>For proper validation, use a period not included in calibration. For example, if calibration used 1990-2000, validate on 2001-2010.</p>"},{"location":"user-guide/simulation/#multimodel-simulation","title":"Multimodel Simulation","text":"<p>When two or more calibrations are imported, enable Multimodel simulation to:</p> <ul> <li>Run each model independently</li> <li>Compute the average of all simulations</li> <li>Evaluate the multimodel ensemble performance</li> </ul> <p>This is disabled when only one calibration is loaded.</p>"},{"location":"user-guide/simulation/#running-a-simulation","title":"Running a Simulation","text":"<ol> <li>Import at least one calibration result</li> <li>Set the simulation period</li> <li>Optionally enable multimodel simulation</li> <li>Click Run</li> </ol> <p>Results appear in the charts on the right.</p> <p></p>"},{"location":"user-guide/simulation/#understanding-results","title":"Understanding Results","text":""},{"location":"user-guide/simulation/#performance-metrics","title":"Performance Metrics","text":"<p>Six bar charts show different performance aspects for each simulation:</p> Metric Description Optimal High flows (NSE) NSE with no transformation 1 Medium flows (NSE-sqrt) NSE with sqrt transformation 1 Low flows (NSE-log) NSE with log transformation 1 Water balance (Mean bias) Average difference from observations 1 Flow variability (Deviation bias) Standard deviation ratio 1 Correlation Linear correlation coefficient 1 <p>Each calibration appears as a separate bar, color-coded to match the streamflow chart.</p>"},{"location":"user-guide/simulation/#streamflow-chart","title":"Streamflow Chart","text":"<p>The time series chart shows:</p> <ul> <li>Observations (blue): Measured streamflow</li> <li>Simulation 1, 2, ... (green, purple, orange, ...): Output from each calibration</li> <li>Multimodel (if enabled): Average of all simulations (color depends on number of loaded calibrations)</li> </ul>"},{"location":"user-guide/simulation/#chart-interactions","title":"Chart Interactions","text":"<ul> <li>Zoom: Click and drag to select a time range</li> <li>Reset: Double-click to return to full view</li> </ul>"},{"location":"user-guide/simulation/#multimodel-performance","title":"Multimodel Performance","text":"<p>When multimodel simulation is enabled, the performance metrics include an additional \"multimodel\" bar showing the ensemble's performance. Multimodel averaging often outperforms individual calibrations by reducing model structural uncertainty.</p>"},{"location":"user-guide/simulation/#exporting-results","title":"Exporting Results","text":"<p>Click Export data to save:</p> <ol> <li> <p>Simulation results (JSON): Configuration and performance metrics</p> <pre><code>{\n  \"calibrationConfig\": [\n    {\"name\": \"simulation_1\", ...},\n    {\"name\": \"simulation_2\", ...}\n  ],\n  \"config\": {\n    \"start\": \"2001-01-01\",\n    \"end\": \"2010-12-31\",\n    \"multimodel\": true\n  },\n  \"results\": [\n    {\"name\": \"simulation_1\", \"nse_none\": 0.85, ...},\n    {\"name\": \"simulation_2\", \"nse_none\": 0.82, ...},\n    {\"name\": \"multimodel\", \"nse_none\": 0.87, ...}\n  ]\n}\n</code></pre> </li> <li> <p>Simulation timeseries (CSV): Daily values for all simulations</p> <pre><code>date,simulation_1,simulation_2,multimodel,observation\n2001-01-01,12.5,13.2,12.85,11.8\n2001-01-02,11.8,12.5,12.15,12.1\n...\n</code></pre> </li> </ol>"},{"location":"user-guide/simulation/#common-issues","title":"Common Issues","text":""},{"location":"user-guide/simulation/#cannot-import-calibration","title":"Cannot Import Calibration","text":"<p>Error: \"This isn't a valid calibrated parameter file\"</p> <ul> <li>Ensure the file is a JSON file exported from HOLMES calibration</li> <li>Check that the file contains all required fields</li> </ul>"},{"location":"user-guide/simulation/#cannot-import-multiple-catchments","title":"Cannot Import Multiple Catchments","text":"<p>Error: \"The calibrations need to be on the same catchment\"</p> <ul> <li>All imported calibrations must be for the same catchment</li> <li>Export new calibrations from the same catchment</li> </ul>"},{"location":"user-guide/simulation/#simulation-already-imported","title":"Simulation Already Imported","text":"<p>Error: \"This calibration is already imported\"</p> <ul> <li>The same calibration file cannot be imported twice</li> <li>Each imported calibration must have unique parameters</li> </ul>"}]}